{"meta":{"version":1,"warehouse":"1.0.3"},"models":{"Asset":[{"_id":"themes/yilia/source/js/pc.js","path":"js/pc.js","modified":1},{"_id":"themes/yilia/source/js/mobile.js","path":"js/mobile.js","modified":1},{"_id":"themes/yilia/source/js/main.js","path":"js/main.js","modified":1},{"_id":"themes/yilia/source/js/jquery.lazyload.js","path":"js/jquery.lazyload.js","modified":1},{"_id":"themes/yilia/source/js/instagram.js","path":"js/instagram.js","modified":1},{"_id":"themes/yilia/source/img/zhihu.png","path":"img/zhihu.png","modified":1},{"_id":"themes/yilia/source/img/weibo.png","path":"img/weibo.png","modified":1},{"_id":"themes/yilia/source/img/twitter.png","path":"img/twitter.png","modified":1},{"_id":"themes/yilia/source/img/stackoverflow.png","path":"img/stackoverflow.png","modified":1},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":1},{"_id":"themes/yilia/source/img/rss.png","path":"img/rss.png","modified":1},{"_id":"themes/yilia/source/img/pinterest.png","path":"img/pinterest.png","modified":1},{"_id":"themes/yilia/source/img/pinboard.png","path":"img/pinboard.png","modified":1},{"_id":"themes/yilia/source/img/mail.png","path":"img/mail.png","modified":1},{"_id":"themes/yilia/source/img/linkedin.png","path":"img/linkedin.png","modified":1},{"_id":"themes/yilia/source/img/img-loading.png","path":"img/img-loading.png","modified":1},{"_id":"themes/yilia/source/img/img-err.png","path":"img/img-err.png","modified":1},{"_id":"themes/yilia/source/img/google.png","path":"img/google.png","modified":1},{"_id":"themes/yilia/source/img/github.png","path":"img/github.png","modified":1},{"_id":"themes/yilia/source/img/facebook.png","path":"img/facebook.png","modified":1},{"_id":"themes/yilia/source/img/douban.png","path":"img/douban.png","modified":1},{"_id":"themes/yilia/source/img/delicious.png","path":"img/delicious.png","modified":1},{"_id":"themes/yilia/source/img/coderwall.png","path":"img/coderwall.png","modified":1},{"_id":"themes/yilia/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":1},{"_id":"themes/yilia/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":1},{"_id":"themes/yilia/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":1},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":1},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":1},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":1},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":1},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":1},{"_id":"themes/yilia/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":1},{"_id":"themes/yilia/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":1},{"_id":"themes/yilia/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":1},{"_id":"themes/yilia/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":1},{"_id":"themes/yilia/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":1},{"_id":"themes/yilia/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":1},{"_id":"themes/yilia/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":1},{"_id":"themes/yilia/source/css/style.styl","path":"css/style.styl","modified":1},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":1},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":1},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.svgz","path":"css/fonts/fontawesome-webfont.svgz","modified":1},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":1},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":1}],"Cache":[{"_id":"source/_posts/C-中的虚函数实现原理.md","shasum":"35df25a96a38dcd2e16ec475c7f54f125d7f201f","modified":1480427265921},{"_id":"source/_posts/C-中的虚继承.md","shasum":"556ea20b42459b468b68225d35426db97ebdb02a","modified":1480427265924},{"_id":"source/_posts/Caffe-with-Python-Layer.md","shasum":"20896488af4d3d1fbea0389bf7f41468e095f81e","modified":1480427265928},{"_id":"source/_posts/Caffe中的Net类是如何工作的.md","shasum":"dacdf6118e43008fcf2451050eb45ae215d39090","modified":1480427265932},{"_id":"source/_posts/Python在Windows环境下处理文件路径问题最佳实践.md","shasum":"7d8ed4b2f5d901160835b65453f1616d1e5a0adc","modified":1480427265934},{"_id":"source/_posts/dl-practical-methodolog.md","shasum":"134608d5edb7aa9199560ec76979edf7deeac39e","modified":1480427265936},{"_id":"source/_posts/torch-hdf5.md","shasum":"5de3014e97dd5a5e33343de9d919b078757ac341","modified":1480427265939},{"_id":"source/_posts/在Windows阅读Caffe代码.md","shasum":"8de74881c5769005e71148955537316e950424e9","modified":1480427265941},{"_id":"source/_posts/在torch中使用cuda进行训练.md","shasum":"22855aadeb3944c0ad060dbb40847d9243163777","modified":1480427265944},{"_id":"source/_posts/数据挖掘中的数据预处理.md","shasum":"1c91022a571c9f2c42b95607cf83e8e3b8de8df6","modified":1480427265947},{"_id":"themes/yilia/README.md","shasum":"8648a81b3ae08a4accd6b0541533e662511e6400","modified":1451035286404},{"_id":"themes/yilia/_config.yml","shasum":"72d7e18bc5c927b9d912a98e6ff86cac519b15d7","modified":1451041760545},{"_id":"themes/yilia/languages/de.yml","shasum":"bc80f78f61c3d7af9652e6aa6fc3e4ff39b0c8d3","modified":1451035286408},{"_id":"themes/yilia/languages/default.yml","shasum":"f0a7a032b31555c9ec05a711e1ac19bb07724708","modified":1451035286410},{"_id":"themes/yilia/languages/en.yml","shasum":"a093e794aef63ec9e9e9ef490cf7e4474e45e59f","modified":1451035286411},{"_id":"themes/yilia/languages/fr-FR.yml","shasum":"04b9a0d80d88d01e039e8077afe88f741e9620ba","modified":1451035286413},{"_id":"themes/yilia/languages/ru.yml","shasum":"62f84ea82a696060c481fc22d4742e6201bb9bdc","modified":1451035286414},{"_id":"themes/yilia/languages/zh-hk.yml","shasum":"e702fc43556e54c396917bdf7c869d528742e28b","modified":1451035286417},{"_id":"themes/yilia/languages/zh-Hans.yml","shasum":"d2336578e14bb880d152266981c2b17523fc8742","modified":1451035286416},{"_id":"themes/yilia/languages/zh-tw.yml","shasum":"005559baa96b7bb34e1efe6b031829a95d58d5e0","modified":1451035286419},{"_id":"themes/yilia/layout/_partial/after-footer.ejs","shasum":"3709af4e8f7e1196dbd1f9dea62fa440d4b47836","modified":1451035286427},{"_id":"themes/yilia/layout/_partial/archive-post.ejs","shasum":"5b29a383418cfdcf8d5c5719b4fc4608aaba6fe7","modified":1451035286429},{"_id":"themes/yilia/layout/_partial/archive.ejs","shasum":"a4eacc2bc1278095a0ef99f904b0634c78f980eb","modified":1451035286434},{"_id":"themes/yilia/layout/_partial/article.ejs","shasum":"420b94c78832456686ebd9831a5bfcb05365645a","modified":1451035286442},{"_id":"themes/yilia/layout/_partial/footer.ejs","shasum":"871f81cacd5d41cb2eb001cd56254217a857dc2f","modified":1451035286444},{"_id":"themes/yilia/layout/_partial/google-analytics.ejs","shasum":"1ccc627d7697e68fddc367c73ac09920457e5b35","modified":1451035286446},{"_id":"themes/yilia/layout/_partial/head.ejs","shasum":"2bbf5aad03f54055d9d7852e70ff7e6952a41f26","modified":1451035286450},{"_id":"themes/yilia/layout/_partial/header.ejs","shasum":"b69855e07b65117769adc515cb64b803932068c9","modified":1451035286460},{"_id":"themes/yilia/layout/_partial/left-col.ejs","shasum":"b03e8424b4798d4887801afdfae457fbf6027838","modified":1451035286469},{"_id":"themes/yilia/layout/_partial/mathjax.ejs","shasum":"7be03a92dabeb2f94bf0e731d12a1c1146d736dd","modified":1451035286477},{"_id":"themes/yilia/layout/_partial/mobile-nav.ejs","shasum":"6a7a2a4960dabf9d7cd523573da7869eebf4b02d","modified":1451035286486},{"_id":"themes/yilia/layout/_partial/post/category.ejs","shasum":"27fab3e6ccc41c075dc4c5ba3ca9e7f3b6247945","modified":1451035286489},{"_id":"themes/yilia/layout/_partial/post/date.ejs","shasum":"06d8914b5aef73b5ec2cabb0105e275ff821b321","modified":1451035286497},{"_id":"themes/yilia/layout/_partial/post/duoshuo.ejs","shasum":"f6b4c4eaafb5ac386273354b5f64a26139b7a3b0","modified":1451035286505},{"_id":"themes/yilia/layout/_partial/post/nav.ejs","shasum":"c115c282eebfb6b18612d2d8733272c270b03066","modified":1451035286507},{"_id":"themes/yilia/layout/_partial/post/share_addthis.ejs","shasum":"4ab6cab2a975a4df8419448b33dec4724279d85c","modified":1451035286508},{"_id":"themes/yilia/layout/_partial/post/share_jia.ejs","shasum":"d50294bf9858e7942208c380e851a37ed37f1d6f","modified":1451035286510},{"_id":"themes/yilia/layout/_partial/post/tag.ejs","shasum":"acf1b9d79ccec172881f9f0080e96667f4178885","modified":1451035286513},{"_id":"themes/yilia/layout/_partial/post/title.ejs","shasum":"d4a460a35e2112d0c7414fd5e19b3a16093f1caf","modified":1451035286515},{"_id":"themes/yilia/layout/archive.ejs","shasum":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1451035286516},{"_id":"themes/yilia/layout/category.ejs","shasum":"765426a9c8236828dc34759e604cc2c52292835a","modified":1451035286517},{"_id":"themes/yilia/layout/index.ejs","shasum":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1451035286518},{"_id":"themes/yilia/layout/layout.ejs","shasum":"3a4350f23a1286345f76c949466c97a7200dae8e","modified":1451035286522},{"_id":"themes/yilia/layout/page.ejs","shasum":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1451035286523},{"_id":"themes/yilia/layout/post.ejs","shasum":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1451035286523},{"_id":"themes/yilia/layout/tag.ejs","shasum":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1451035286525},{"_id":"themes/yilia/package.json","shasum":"0199dfb3d44cf520b67464817d13c44a7766b8d6","modified":1451035286526},{"_id":"themes/yilia/source/css/_extend.styl","shasum":"8ab1ad313bd6707d248c5ca1ee9a5eab8d815e42","modified":1451035286530},{"_id":"themes/yilia/source/css/_partial/archive.styl","shasum":"8b349f1605024dcdae054e04f02d71a2e84957c2","modified":1451035286531},{"_id":"themes/yilia/source/css/_partial/article.styl","shasum":"872fc4e63509fef885c939e5fd70e6ed439beced","modified":1451035286533},{"_id":"themes/yilia/source/css/_partial/footer.styl","shasum":"7ca837a4cc34db1c35f01baec85eb10ccc64ea86","modified":1451035286534},{"_id":"themes/yilia/source/css/_partial/header.styl","shasum":"67e59feb18eee6026717cb440d86ab9551782628","modified":1451035286536},{"_id":"themes/yilia/source/css/_partial/highlight.styl","shasum":"08d3205dde3235f3e6881126268e6c473f46a8ac","modified":1451035286538},{"_id":"themes/yilia/source/css/_partial/instagram.styl","shasum":"8a7b07bf5ea2d3588c0019f722c245bb1a8696af","modified":1451035286539},{"_id":"themes/yilia/source/css/_partial/main.styl","shasum":"c368f1533053d4cffdf0ad982603271400b08e33","modified":1451035286541},{"_id":"themes/yilia/source/css/_partial/mobile-slider.styl","shasum":"e19c7fae6968ad3ea6cfc110900a991f9b5fce31","modified":1451035286542},{"_id":"themes/yilia/source/css/_partial/mobile.styl","shasum":"3a03b04ef8ac305aa5dbf7b9db99cd9377d07383","modified":1451035286544},{"_id":"themes/yilia/source/css/_partial/page.styl","shasum":"720b5b169bc28ccba3794efce9b7cd39f243dec7","modified":1451035286546},{"_id":"themes/yilia/source/css/_partial/scroll.styl","shasum":"5539a38f9acd603d453a0ea0d8ce10893cf83d22","modified":1451035286547},{"_id":"themes/yilia/source/css/_partial/share.styl","shasum":"22697b9a9877ab9f018364feb57aeea4a8313c9a","modified":1451035286548},{"_id":"themes/yilia/source/css/_partial/tagcloud.styl","shasum":"af0115de5c6455f899a2e09225b50224982c039d","modified":1451035286550},{"_id":"themes/yilia/source/css/_partial/wheelmenu.styl","shasum":"9e57421eab562ea13d0ed2b2e1415eee79fa23d0","modified":1451035286551},{"_id":"themes/yilia/source/css/_util/grid.styl","shasum":"1aa883ab432d9e4139c89dcbd40ae2bd1528d029","modified":1451035286553},{"_id":"themes/yilia/source/css/_util/mixin.styl","shasum":"429bad87fc156eacf226c5e35b0eafc277f2504b","modified":1451035286554},{"_id":"themes/yilia/source/css/_variables.styl","shasum":"8b63ea3c7199524b9a1541075c6f8fb2c0d0ea3d","modified":1451035286556},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.eot","shasum":"3ce87b82c7a4ffdf65e96765c2ffda10b1a283c6","modified":1451035286560},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.svgz","shasum":"4bfdd33ed702e32ae01399fcc2652377f78e7626","modified":1451035286565},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.ttf","shasum":"1480b8101b02da9bc4c60341b5e185e63e585064","modified":1451035286568},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.woff","shasum":"cafc4ac5761a0a252d33dce4ea3952cf9a38d832","modified":1451035286570},{"_id":"themes/yilia/source/css/style.styl","shasum":"456e8cfe3b0b0371e81848ea9b0bc7ffd5360921","modified":1451035286572},{"_id":"themes/yilia/source/fancybox/blank.gif","shasum":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1451035286572},{"_id":"themes/yilia/source/fancybox/fancybox_loading.gif","shasum":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1451035286573},{"_id":"themes/yilia/source/fancybox/fancybox_loading@2x.gif","shasum":"273b123496a42ba45c3416adb027cd99745058b0","modified":1451035286574},{"_id":"themes/yilia/source/fancybox/fancybox_overlay.png","shasum":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1451035286574},{"_id":"themes/yilia/source/fancybox/fancybox_sprite.png","shasum":"17df19f97628e77be09c352bf27425faea248251","modified":1451035286575},{"_id":"themes/yilia/source/fancybox/fancybox_sprite@2x.png","shasum":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1451035286576},{"_id":"themes/yilia/source/fancybox/helpers/fancybox_buttons.png","shasum":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1451035286576},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-buttons.css","shasum":"6394c48092085788a8c0ef72670b0652006231a1","modified":1451035286578},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-buttons.js","shasum":"4c9c395d705d22af7da06870d18f434e2a2eeaf9","modified":1451035286580},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-media.js","shasum":"e14c32cc6823b81b2f758512f13ed8eb9ef2b454","modified":1451035286583},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-thumbs.css","shasum":"b88b589f5f1aa1b3d87cc7eef34c281ff749b1ae","modified":1451035286585},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-thumbs.js","shasum":"83cdfea43632b613771691a11f56f99d85fb6dbd","modified":1451035286588},{"_id":"themes/yilia/source/fancybox/jquery.fancybox.css","shasum":"96138eaddfbd305160ddcb98a5f08555ca6cb4ee","modified":1451035286590},{"_id":"themes/yilia/source/fancybox/jquery.fancybox.js","shasum":"004bb0812414554ab48067792f09e978603253b6","modified":1451035286596},{"_id":"themes/yilia/source/fancybox/jquery.fancybox.pack.js","shasum":"2da892a02778236b64076e5e8802ef0566e1d9e8","modified":1451035286603},{"_id":"themes/yilia/source/img/coderwall.png","shasum":"fa84676c4d654e040e51fd34bfcd9f9348cd5331","modified":1451035286604},{"_id":"themes/yilia/source/img/delicious.png","shasum":"9553a5f5189e4a953e04a58a49dbfa74b86b73dd","modified":1451035286604},{"_id":"themes/yilia/source/img/douban.png","shasum":"e2ade003ffadd5826ee66ec23901c2d6e8607e4e","modified":1451035286605},{"_id":"themes/yilia/source/img/facebook.png","shasum":"d19ad7a0903daf26817afd8753cd97e0cc714f54","modified":1451035286605},{"_id":"themes/yilia/source/img/github.png","shasum":"b84d03b32fa388dcbf149296ebd16dce6223d48d","modified":1451035286606},{"_id":"themes/yilia/source/img/google.png","shasum":"61a21fec7346fa3400b747ac9a201cf3d5bc013d","modified":1451035286606},{"_id":"themes/yilia/source/img/img-err.png","shasum":"23a63ea26eb3c1d5e677d9883cf36cc1a1a1228b","modified":1451035286607},{"_id":"themes/yilia/source/img/img-loading.png","shasum":"a9cd5cd11866824f31e3d1c5e23badfeb3f73031","modified":1451035286608},{"_id":"themes/yilia/source/img/linkedin.png","shasum":"e203138fb53c257cb214e97f4e30091b9c568d2c","modified":1451035286608},{"_id":"themes/yilia/source/img/mail.png","shasum":"fca8199cc77fdbd700a45bf56d091c82f4a67fe7","modified":1451035286609},{"_id":"themes/yilia/source/img/pinboard.png","shasum":"0891fbb6d092fa012bf936019923383d84c6aeb0","modified":1451035286609},{"_id":"themes/yilia/source/img/pinterest.png","shasum":"9c72917f8779c083157c6ce7a5d62ed4874f0630","modified":1451035286609},{"_id":"themes/yilia/source/img/rss.png","shasum":"430fd47340e75214c081abd05cd7410cf7c71b86","modified":1451035286610},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","shasum":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1451035286610},{"_id":"themes/yilia/source/img/stackoverflow.png","shasum":"da5dfe9043055c95e479d49c78cd3b020de608f2","modified":1451035286611},{"_id":"themes/yilia/source/img/twitter.png","shasum":"14dbb8e62d056525253bc0de13acd1723da7a934","modified":1451035286611},{"_id":"themes/yilia/source/img/weibo.png","shasum":"280dae3fd38086158b4a1b57edb94c06b1a5014b","modified":1451035286612},{"_id":"themes/yilia/source/img/zhihu.png","shasum":"a6d6ef65e9ac82e613a311810391ebb90d9b1c1d","modified":1451035286612},{"_id":"themes/yilia/source/js/instagram.js","shasum":"81e13cacf4947118ed1920e59b04ccf6beef6b86","modified":1451035286620},{"_id":"themes/yilia/source/js/jquery.lazyload.js","shasum":"9c34c37b4dca82386648d364da913153d1db902e","modified":1451035286623},{"_id":"themes/yilia/source/js/main.js","shasum":"e2633f282e377a4169649c9f17dc96036ad4fc64","modified":1451035286626},{"_id":"themes/yilia/source/js/mobile.js","shasum":"387c047e661f04fbb5f5bfc4b2db617023e836ce","modified":1451035286629},{"_id":"themes/yilia/source/js/pc.js","shasum":"a5397d34a04084ee089b4b1e26457ab46ecea63e","modified":1451035286632},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.svg","shasum":"ba13657479b46daecb6336bfe376f84cef3ae58b","modified":1451035286563}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"C++中的虚函数实现原理","date":"2016-03-21T12:21:47.000Z","_content":">参考资料：[C++ Under the hood](http://www.hanese.nl/~ewout/ESE/INF2/CPP_onder_de_motorkap.pdf)\n\n\n### 虚函数是C++中[多态特性](http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/001386820044406b227b3e751cc4d5190420d17a2dc6353000)的实现基础。\n### 0.首先定义一个基类B与派生类D来辅助说明问题：\n```C++\n   class B{\npublic:\nB();\nvirtual ~ B();\nvirtual void fun1();\nvirtual void fun2();\nvirtual void fun3();\nvoid fun4 const();\n}\n\nclass D:public B{\nD();\n~D();\nvirtual void fun1();\nvoid fun5();\n\n}\n```\n#### 1.虚函数的原理可以概括如下：\n* 对于含有虚函数的类，编译器会为其建立一个虚函数表(vtbl)，表中的元素是指向虚函数代码所在位置的指针。\n![B的虚函数表](http://7xs45i.com1.z0.glb.clouddn.com/withwsfScreenshot%20from%202016-03-21%2020-41-48.png)\n* 派生类的虚函数表继承自基类并添加自己的虚函数（示例代码中D新定义的虚函数D::fun5将会被添加到虚函数表）。如果基类的虚函数被派生类重载（在上面的示例代码中基类的虚函数fun1被派生类的虚函数fun1覆盖），那么由派生类虚函数代替基类虚函数的位置（B::~B和B::fun1将被D::~D和D::fun1代替）。\n![D的虚函数表](http://7xs45i.com1.z0.glb.clouddn.com/withwsfSelection_001.png)\n* 含有虚函数的类的每个对象中都有一个指针（称为vptr,一般放在对象所在内存的首地址），指向类的虚函数表。\n![vptr与指向的vtbl](http://7xs45i.com1.z0.glb.clouddn.com/withwsfSelection_002.png)\n* 由于派生对其继承自基类的虚函数表进行了改写，所以当基类的指针或引用被绑定到派生类对象时，尽管静态类型是基类，却可以调用派生类覆盖后的虚函数。\n\n### 2.多重继承时的情况\n```C++\nclass B1{\nB1()\nvirtual ~B();\n}\nclass B2{\nB2()\nvirtual ~B2();\n}\n\nclass D:public B1, public B2{\n~D();\n}\n```\n* 编译器会为继承自多个基类的派生类产生与基类个数相同的虚函数表，并在继承自第一个基类的虚函数表上添加派生类新定义的虚函数。\n* 派生类的对象中也会含有与基类个数相同的vptr。\n* 将派生类对象绑定到不同的基类指针（或引用）时，编译器将根据基类指针（或引用）的不同选择使用不同的虚函数表（派生类的指针(或引用)与第一个基类的指针(或引用)使用同一个虚函数表）。！\n![多重继承下的虚函数表](http://7xs45i.com1.z0.glb.clouddn.com/withwsfSelection_003.png)\n","source":"_posts/C-中的虚函数实现原理.md","raw":"title: C++中的虚函数实现原理\ndate: 2016-03-21 20:21:47\ntags: C++\n---\n>参考资料：[C++ Under the hood](http://www.hanese.nl/~ewout/ESE/INF2/CPP_onder_de_motorkap.pdf)\n\n\n### 虚函数是C++中[多态特性](http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/001386820044406b227b3e751cc4d5190420d17a2dc6353000)的实现基础。\n### 0.首先定义一个基类B与派生类D来辅助说明问题：\n```C++\n   class B{\npublic:\nB();\nvirtual ~ B();\nvirtual void fun1();\nvirtual void fun2();\nvirtual void fun3();\nvoid fun4 const();\n}\n\nclass D:public B{\nD();\n~D();\nvirtual void fun1();\nvoid fun5();\n\n}\n```\n#### 1.虚函数的原理可以概括如下：\n* 对于含有虚函数的类，编译器会为其建立一个虚函数表(vtbl)，表中的元素是指向虚函数代码所在位置的指针。\n![B的虚函数表](http://7xs45i.com1.z0.glb.clouddn.com/withwsfScreenshot%20from%202016-03-21%2020-41-48.png)\n* 派生类的虚函数表继承自基类并添加自己的虚函数（示例代码中D新定义的虚函数D::fun5将会被添加到虚函数表）。如果基类的虚函数被派生类重载（在上面的示例代码中基类的虚函数fun1被派生类的虚函数fun1覆盖），那么由派生类虚函数代替基类虚函数的位置（B::~B和B::fun1将被D::~D和D::fun1代替）。\n![D的虚函数表](http://7xs45i.com1.z0.glb.clouddn.com/withwsfSelection_001.png)\n* 含有虚函数的类的每个对象中都有一个指针（称为vptr,一般放在对象所在内存的首地址），指向类的虚函数表。\n![vptr与指向的vtbl](http://7xs45i.com1.z0.glb.clouddn.com/withwsfSelection_002.png)\n* 由于派生对其继承自基类的虚函数表进行了改写，所以当基类的指针或引用被绑定到派生类对象时，尽管静态类型是基类，却可以调用派生类覆盖后的虚函数。\n\n### 2.多重继承时的情况\n```C++\nclass B1{\nB1()\nvirtual ~B();\n}\nclass B2{\nB2()\nvirtual ~B2();\n}\n\nclass D:public B1, public B2{\n~D();\n}\n```\n* 编译器会为继承自多个基类的派生类产生与基类个数相同的虚函数表，并在继承自第一个基类的虚函数表上添加派生类新定义的虚函数。\n* 派生类的对象中也会含有与基类个数相同的vptr。\n* 将派生类对象绑定到不同的基类指针（或引用）时，编译器将根据基类指针（或引用）的不同选择使用不同的虚函数表（派生类的指针(或引用)与第一个基类的指针(或引用)使用同一个虚函数表）。！\n![多重继承下的虚函数表](http://7xs45i.com1.z0.glb.clouddn.com/withwsfSelection_003.png)\n","slug":"C-中的虚函数实现原理","published":1,"updated":"2016-11-29T13:47:45.921Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw3lgiuj0000wsgsiiryb2aw"},{"title":"数据挖掘中的数据预处理","date":"2015-12-29T14:13:02.000Z","_content":"### 0.0 关于 《DATA MINING---Concepts and Techniques》\n《DATA MINING---Concepts and Techniques》是经典的数据挖掘入门书籍，内容囊括数据挖掘的基本概念、数据的预处理、数据的存储、数据中模式的挖掘、分类、聚类、异常检测等方面，作者是著名的韩家炜教授。数据的预处理在真实世界数据中是非常关键的一步，它既是不同数据挖掘应用的共同起点，又很大程度上影响了数据挖掘应用的效果。我将翻译、整理这本书中关于数据预处理的部分，如果有纰漏欢迎指正。\n### 0.1 数据预处理综述\n* 由于真实世界中的数据来源复杂、体积巨大，往往难以避免地存在缺失、噪声、不一致（inconsistencies）等问题。\n* 当数据的维数过高时还会存在所谓的“[维数诅咒（Curse of dimensionality）](http://homes.cs.washington.edu/~pedrod/papers/cacm12.pdf)”问题，过高的维度不仅增加了计算量，反而可能会降低算法的效果。\n*  有些算法对数据存在特殊的要求，比如KNN、Neural Networks、Clustering等基于距离（distance based）的算法在数据进行normalize之后效果会提升。\n\n解决上述问题需要在将数据送入算法之前进行预处理，具体包括**Data Cleaning**,**Data Intergation**，**Data reduction**,**Data Transformation and Data Discretization**等步骤。下面将对各个部分详细展开。\n\n### 1. 数据清洗（Data Cleaning）\n数据清洗的主要作用是处理数据的某些纪录值缺失，平滑数据中的噪声、发现异常值，改正不一致。\n#### 值缺失\n针对数据中某些记录的值缺失问题（比如用户销售数据中，有些顾客的收入信息缺失，有些顾客的年龄信息缺失），可以采用如下的方式：\n* 忽略存在缺失值的记录。在分类问题中，如果样本（本文中，'一个样本'和'一条记录'是同义词）的label缺失了，那么这个样本一定是要丢弃的。其他情况下，除非一条记录缺失了多个值，否则这种简单粗暴的方法往往效果不好，尤其当不同的属性值缺失状况相差很大时，效果会更差。\n* 手动填写缺失的值。根据经验手工补上缺失的值，但是这种活儿谁愿意干呢？\n* 用全局的常量来替代缺失值。再拿用户销售数据做例子，对于年龄缺失的纪录年龄全用unknow来代替，但是对于数据挖掘算法来说，young和unknow并没有什么本质的不同，都只是属性值的一种而已，所以所有年龄缺失的纪录在算法看来都是同一种年龄----“unknow”,这反而可能会降低算法的效果。\n* 使用中值和均值来替代缺失值。某种属性的中值和均值代表了此属性的平均趋势，用它们来代替缺失值不失为一种可行的方案。但是，当属性是“红、绿、蓝”这种离散值时显然不存在中值、均值的概念。\n* 使用class-specific的中值和均值来代替缺失值。在有监督问题中，一个基本假设是label相同的样本属性也相似，那么，某个样本的缺失值，用其所在类别内的所有样本的在此属性的均值或中值来代替理应效果更好。\n* 使用最可能的值来填充缺失值。用此样本的其他属性来推断缺失属性的最可能值，实际上这就变成了一个回归或分类问题（属性值连续时是回归问题，离散时是分类问题）。实际中常用[贝叶斯推理](https://en.wikipedia.org/wiki/Bayesian_inference)或决策树来解决上述问题。\n\n上述的第3-第6种方法都会引入偏差，因为补充的缺失值跟真实值很可能不同。第六种方法在现实中非常流行，因为它在推断缺失值时使用的信息最多，那么结果理应更准确。不过需要注意的是，有时缺失值也会提供有用的信息，比如在信用卡申请用户数据中，没有驾照号码很可能是因为没有汽车，而是否有汽车是评价信用等级很有用的信息。\n#### 噪声（noise）\n噪声是混在观测值的错误(error)或误差(variance)，具体去噪方式有以下几种：\n* Binning。Data Bininig，又称为Bucketing，从字面意思来展开，就是把样本点按照一定的准则分配到不同的bin(bucket)中去，然后对每个样本点根据其所在bin内样本点的分布来赋一个新值，同一个bin的样本点被赋予的新值是一致的。对于一维数据，bin可以按照区间大小划分，也可以按照data frequency来划分，而每个bin的值可以选择分布在其中样本的均值、中值或者边界值。另外，CNN中的max-pooling层，也属于data binning的范畴，典型的max-pooling层bin的尺寸为2*2，选择每个bin中的最大值作为bin四个值的新值。\n* 回归。如果变量之间存在依赖关系，即y=f(x)，那么我们可以设法求出依赖关系f，从而根据x来预测y，这也是回归问题的实质。实际中更常见的假设是P(y)=N(f(x))，N是正态分布。假设y是观测值且存在噪声，如果我们能求出x和y之间的依赖关系，从而根据x来更新y的值，就可以去除其中的随机噪声，这就是回归去噪的原理。\n* 异常值检测。数据中的噪声可能有两种，一种是随机误差，另外一种可能是错误，比如我们手上有一份顾客的身高数据，其中某一位顾客的身高纪录是20m，很明显，这是一个错误，如果这个一场的样本进入了我们训练数据可能会对结果产生很大影响，这也是去噪中使用异常值检测的意义所在。当然，异常值检测远不止去噪这么一个应用，网络入侵检测、视频中行人异常行为检测、欺诈检测等都是异常值检测的应用。异常值检测方法也分为有监督，无监督和半监督方法，这里不再详细展开。\n### 2. 数据融合\n所谓数据融合就是将不同来源的、异质的数据融合到一起。良好的数据融合可以减少数据中的冗余(redundacies)和不一致性(inconsistence)，进而提升后续步骤的精度和速度。数据融合包括如下几个步骤：\n#### 实体识别问题（Entity  Identification Problem）\n实体识别中最主要的问题匹配不同的数据源中指向现实世界相同实体的纪录。比如分析有不同销售员纪录的14年和15年两年的销售数据，由于不同的销售员有不同的纪录习惯，顾客的名字纪录方式并不一样，一个销售员喜欢纪录全名（例如 Wardell Stephen Curry II），另外一个销售员喜欢将中间名省略（Wardell S Curry II ），虽然Wardell Stephen Curry II和Wardell S Curry II是现实世界中是同一名顾客，但计算机会识别为两位不同的顾客，解决这个问题就需要Entity Identification。一个常用的Entity Indentification Problem的解决算法是[LSH算法](http://www.mit.edu/~andoni/LSH/)\n另外一个问题是Schema integration, Schenma在这里指使用DBMS支持的形式化语言对一个数据库的结构化描述，Schema是构建一个数据库的蓝图。Schema intergration则是指，将若干个Schema合成一个global Schema，这个global Schema可以表达所有子Schema的要求（也就是一个总的蓝图）。属性的metadata（比如名称、取值范围、空值处理方法）可以帮助减少Schema Intergration的错误。\n#### 冗余和相关性分析\n当能够从样本的一个或多个属性推导出另外的属性的时候，那么数据中就存在冗余。检测冗余的一种方法是相关性分析----给定要进行检测的两个属性，相关性分析可以给出一个属性隐含(**imply**)另外一个属性的程度。对于标称型（**Nominal**）数据，可以使用$\\\\chi^2$检验，而对于数值数据，可以根据方差和相关系数来分析。\n* 标称数据的$\\\\chi^2$相关性检验。\n假设有A和B两个属性，A有$a_1,a_2,...a_c$共c种不同的取值，B有$b_1,b_2,...b_r$共r种不同的取值。我们可以为属性A和B建立一个列联表(**contingency table**)C，所谓列联表，就是一个r*c的矩阵，位置（i,j）代表属性A的值$a_i$和属性B的值$b_i$在样本中同时出现(事件(A=$a_i$,B=$b_j$)发生)的频率$o_ij$。属性A和属性B的$\\\\chi^2$值可以通过下面的式子计算：\n>{% math %}\\chi^2=\\sum_{i=1}^{c}\\sum_{j=1}^{r}\\frac{(o_{ij}-e_{ij})^2}{e_{ij}}{% endmath %}     (1)\n\n\n其中$o_ij$是联合事件(A=$a_i$,B=$b_j$)发生的频率，$e_ij$是期望频率，用如下的公式计算：\n>{% math %}e_{ij}=\\frac{count(A=a_i)\\times count(B=b_j)}{n}{% endmath %}                          (2)\n\n* 数值数据的相关系数\n假设有n个样本，$S_1,S_2,...S_n$,样本$S_i$的A，B两种属性的值分别是$a_i,b_i$，那么属性A和B的相关系数定义是：\n>{% math %}r_{A,B}=\\frac{\\sum_{i=1}^{n}(a_i-\\overline{A})(b_i-\\overline{B})}{n\\delta_A\\delta_B}=\\frac{\\sum_{i=n}^{n}(a_i b_i)-n\\overline{A} \\overline{B}}{n\\delta_A\\delta_B}{% endmath %}                                                                                             （3）\n\n当相关系数是正的时候表示属性A和属性B正相关，当相关系数是负的时候属性A和属性B负相关，注意，相关关系并不等同于因果关系。\n\n\n\n","source":"_posts/数据挖掘中的数据预处理.md","raw":"title: 数据挖掘中的数据预处理\ndate: 2015-12-29 22:13:02\ntags: [数据挖掘,阅读经典]\n---\n### 0.0 关于 《DATA MINING---Concepts and Techniques》\n《DATA MINING---Concepts and Techniques》是经典的数据挖掘入门书籍，内容囊括数据挖掘的基本概念、数据的预处理、数据的存储、数据中模式的挖掘、分类、聚类、异常检测等方面，作者是著名的韩家炜教授。数据的预处理在真实世界数据中是非常关键的一步，它既是不同数据挖掘应用的共同起点，又很大程度上影响了数据挖掘应用的效果。我将翻译、整理这本书中关于数据预处理的部分，如果有纰漏欢迎指正。\n### 0.1 数据预处理综述\n* 由于真实世界中的数据来源复杂、体积巨大，往往难以避免地存在缺失、噪声、不一致（inconsistencies）等问题。\n* 当数据的维数过高时还会存在所谓的“[维数诅咒（Curse of dimensionality）](http://homes.cs.washington.edu/~pedrod/papers/cacm12.pdf)”问题，过高的维度不仅增加了计算量，反而可能会降低算法的效果。\n*  有些算法对数据存在特殊的要求，比如KNN、Neural Networks、Clustering等基于距离（distance based）的算法在数据进行normalize之后效果会提升。\n\n解决上述问题需要在将数据送入算法之前进行预处理，具体包括**Data Cleaning**,**Data Intergation**，**Data reduction**,**Data Transformation and Data Discretization**等步骤。下面将对各个部分详细展开。\n\n### 1. 数据清洗（Data Cleaning）\n数据清洗的主要作用是处理数据的某些纪录值缺失，平滑数据中的噪声、发现异常值，改正不一致。\n#### 值缺失\n针对数据中某些记录的值缺失问题（比如用户销售数据中，有些顾客的收入信息缺失，有些顾客的年龄信息缺失），可以采用如下的方式：\n* 忽略存在缺失值的记录。在分类问题中，如果样本（本文中，'一个样本'和'一条记录'是同义词）的label缺失了，那么这个样本一定是要丢弃的。其他情况下，除非一条记录缺失了多个值，否则这种简单粗暴的方法往往效果不好，尤其当不同的属性值缺失状况相差很大时，效果会更差。\n* 手动填写缺失的值。根据经验手工补上缺失的值，但是这种活儿谁愿意干呢？\n* 用全局的常量来替代缺失值。再拿用户销售数据做例子，对于年龄缺失的纪录年龄全用unknow来代替，但是对于数据挖掘算法来说，young和unknow并没有什么本质的不同，都只是属性值的一种而已，所以所有年龄缺失的纪录在算法看来都是同一种年龄----“unknow”,这反而可能会降低算法的效果。\n* 使用中值和均值来替代缺失值。某种属性的中值和均值代表了此属性的平均趋势，用它们来代替缺失值不失为一种可行的方案。但是，当属性是“红、绿、蓝”这种离散值时显然不存在中值、均值的概念。\n* 使用class-specific的中值和均值来代替缺失值。在有监督问题中，一个基本假设是label相同的样本属性也相似，那么，某个样本的缺失值，用其所在类别内的所有样本的在此属性的均值或中值来代替理应效果更好。\n* 使用最可能的值来填充缺失值。用此样本的其他属性来推断缺失属性的最可能值，实际上这就变成了一个回归或分类问题（属性值连续时是回归问题，离散时是分类问题）。实际中常用[贝叶斯推理](https://en.wikipedia.org/wiki/Bayesian_inference)或决策树来解决上述问题。\n\n上述的第3-第6种方法都会引入偏差，因为补充的缺失值跟真实值很可能不同。第六种方法在现实中非常流行，因为它在推断缺失值时使用的信息最多，那么结果理应更准确。不过需要注意的是，有时缺失值也会提供有用的信息，比如在信用卡申请用户数据中，没有驾照号码很可能是因为没有汽车，而是否有汽车是评价信用等级很有用的信息。\n#### 噪声（noise）\n噪声是混在观测值的错误(error)或误差(variance)，具体去噪方式有以下几种：\n* Binning。Data Bininig，又称为Bucketing，从字面意思来展开，就是把样本点按照一定的准则分配到不同的bin(bucket)中去，然后对每个样本点根据其所在bin内样本点的分布来赋一个新值，同一个bin的样本点被赋予的新值是一致的。对于一维数据，bin可以按照区间大小划分，也可以按照data frequency来划分，而每个bin的值可以选择分布在其中样本的均值、中值或者边界值。另外，CNN中的max-pooling层，也属于data binning的范畴，典型的max-pooling层bin的尺寸为2*2，选择每个bin中的最大值作为bin四个值的新值。\n* 回归。如果变量之间存在依赖关系，即y=f(x)，那么我们可以设法求出依赖关系f，从而根据x来预测y，这也是回归问题的实质。实际中更常见的假设是P(y)=N(f(x))，N是正态分布。假设y是观测值且存在噪声，如果我们能求出x和y之间的依赖关系，从而根据x来更新y的值，就可以去除其中的随机噪声，这就是回归去噪的原理。\n* 异常值检测。数据中的噪声可能有两种，一种是随机误差，另外一种可能是错误，比如我们手上有一份顾客的身高数据，其中某一位顾客的身高纪录是20m，很明显，这是一个错误，如果这个一场的样本进入了我们训练数据可能会对结果产生很大影响，这也是去噪中使用异常值检测的意义所在。当然，异常值检测远不止去噪这么一个应用，网络入侵检测、视频中行人异常行为检测、欺诈检测等都是异常值检测的应用。异常值检测方法也分为有监督，无监督和半监督方法，这里不再详细展开。\n### 2. 数据融合\n所谓数据融合就是将不同来源的、异质的数据融合到一起。良好的数据融合可以减少数据中的冗余(redundacies)和不一致性(inconsistence)，进而提升后续步骤的精度和速度。数据融合包括如下几个步骤：\n#### 实体识别问题（Entity  Identification Problem）\n实体识别中最主要的问题匹配不同的数据源中指向现实世界相同实体的纪录。比如分析有不同销售员纪录的14年和15年两年的销售数据，由于不同的销售员有不同的纪录习惯，顾客的名字纪录方式并不一样，一个销售员喜欢纪录全名（例如 Wardell Stephen Curry II），另外一个销售员喜欢将中间名省略（Wardell S Curry II ），虽然Wardell Stephen Curry II和Wardell S Curry II是现实世界中是同一名顾客，但计算机会识别为两位不同的顾客，解决这个问题就需要Entity Identification。一个常用的Entity Indentification Problem的解决算法是[LSH算法](http://www.mit.edu/~andoni/LSH/)\n另外一个问题是Schema integration, Schenma在这里指使用DBMS支持的形式化语言对一个数据库的结构化描述，Schema是构建一个数据库的蓝图。Schema intergration则是指，将若干个Schema合成一个global Schema，这个global Schema可以表达所有子Schema的要求（也就是一个总的蓝图）。属性的metadata（比如名称、取值范围、空值处理方法）可以帮助减少Schema Intergration的错误。\n#### 冗余和相关性分析\n当能够从样本的一个或多个属性推导出另外的属性的时候，那么数据中就存在冗余。检测冗余的一种方法是相关性分析----给定要进行检测的两个属性，相关性分析可以给出一个属性隐含(**imply**)另外一个属性的程度。对于标称型（**Nominal**）数据，可以使用$\\\\chi^2$检验，而对于数值数据，可以根据方差和相关系数来分析。\n* 标称数据的$\\\\chi^2$相关性检验。\n假设有A和B两个属性，A有$a_1,a_2,...a_c$共c种不同的取值，B有$b_1,b_2,...b_r$共r种不同的取值。我们可以为属性A和B建立一个列联表(**contingency table**)C，所谓列联表，就是一个r*c的矩阵，位置（i,j）代表属性A的值$a_i$和属性B的值$b_i$在样本中同时出现(事件(A=$a_i$,B=$b_j$)发生)的频率$o_ij$。属性A和属性B的$\\\\chi^2$值可以通过下面的式子计算：\n>{% math %}\\chi^2=\\sum_{i=1}^{c}\\sum_{j=1}^{r}\\frac{(o_{ij}-e_{ij})^2}{e_{ij}}{% endmath %}     (1)\n\n\n其中$o_ij$是联合事件(A=$a_i$,B=$b_j$)发生的频率，$e_ij$是期望频率，用如下的公式计算：\n>{% math %}e_{ij}=\\frac{count(A=a_i)\\times count(B=b_j)}{n}{% endmath %}                          (2)\n\n* 数值数据的相关系数\n假设有n个样本，$S_1,S_2,...S_n$,样本$S_i$的A，B两种属性的值分别是$a_i,b_i$，那么属性A和B的相关系数定义是：\n>{% math %}r_{A,B}=\\frac{\\sum_{i=1}^{n}(a_i-\\overline{A})(b_i-\\overline{B})}{n\\delta_A\\delta_B}=\\frac{\\sum_{i=n}^{n}(a_i b_i)-n\\overline{A} \\overline{B}}{n\\delta_A\\delta_B}{% endmath %}                                                                                             （3）\n\n当相关系数是正的时候表示属性A和属性B正相关，当相关系数是负的时候属性A和属性B负相关，注意，相关关系并不等同于因果关系。\n\n\n\n","slug":"数据挖掘中的数据预处理","published":1,"updated":"2016-11-29T13:47:45.947Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw3lgiuz0003wsgsegpw51te"},{"title":"在torch中使用cuda进行训练","date":"2015-12-29T07:50:33.000Z","_content":"### 0. 说明\n本文介绍**hdf5文件的读取**、**网络的定义**与**训练**和**测试**，并强调了如何使用**cuda**对网络的训练、测试进行加速。\n### 1. 过程与代码\n* **1 安装hdf5** \n按照[官方tutorial](https://github.com/deepmind/torch-hdf5/blob/master/doc/usage.md)安装torch对hdf5格式文件的支持。\n* **2 引入必要 package 并读入hdf5数据**\n```Lua\n  require 'torch';----如果是在itorch或itorch notbook中自动引入torch\n  require 'hdf5';----hdf5支持\n  require 'nn'; ----neural network modules 的实现\n  require 'cutorch';----cuda backend支持\n  require 'cunn';----neural network modules的cuda实现\n```\n  下面读入数据，假设train和test数据都是按照我[上篇文章](http://withwsf.github.io/2015/12/23/torch-hdf5/)的格式所存储：\n```Lua\nmyFiletrian=hdf5.open('mytrain.h5','r')----读取hdf5文件\nmyFiletest=hdf5.open('mytest.h5','r')\n----将读入的hdf5存到两个Table： trainset和testset中\ntrainset={data=myFiletrian:read('data'):all(),label=myFiletrian:read('label'):all():byte()}\ntestset={data=myFiletest:read('data'):all(),label=myFiletest:read('label'):all():byte()}\n```\n* **3 重载trainset的_index操作符并添加成员函数size()**\n  Lua中也存在面向对象的概念，Lua中的类可以通过Table+function模拟出来。这里将trainset视作一个类的对象，torch要求这个类有方法trainset:size()可以返回样本个数，使用操作符trainset[i]时返回第i个样本。\n```Lua\nsetmetatable(trainset, ----重载index操作符\n    {__index = function(t, i) \n                    return {t.data[i], t.label[i]} \n                end}\n);\n\nfunction trainset:size()----添加成员函数 size()\n    return self.data:size(1)\nend\n```\n* **4 建立一个网络**\n  我使用Torch的主要原因是因为Torch有3D conv模块，所以这里以模仿**LeNet**的3D conv网络为例：\n```Lua\nnet=nn.Sequential()\nnet:add(nn.VolumetricConvolution(3,5,3,3,3))----添加3D conv层，输入3个feature cube，输出5个feature cube，filter size为3*3*3\nnet:add(nn.VolumetricMaxPooling(2,2,2,2,2,2))----添加3D MaxPooling层\nnet:add(nn.VolumetricConvolution(5,16,4,4,4))\nnet:add(nn.VolumetricMaxPooling(2,2,2,2,2,2))\nnet:add(nn.View(16*4*4*4))----连接全连接层之前要使用nn.View()进行reshpe，nn.View()里面的参数需要根据\n---（接上）数据的尺寸和前面的层来计算，比如在这里我是用的训练数据是3*24*24*24的cube,分别经过3*3*3和4*4*4 filter尺寸的两次卷积和两次maxpooling之后最终的输出是16个4*4*4*的feature cube ，那么nn.View()里面的参数就应该是16*4*4*4\nnet:add(nn.Linear(16*4*4*4,120))\nnet:add(nn.Linear(120,84))----nn.Linear(a,b)，设置a个输入neurons和b个输出neurons的全全连接层\nnet:add(nn.Linear(84,7))\nnet:add(nn.LogSoftMax())-----输出每个类别概率P的log函数值log(P)\n\n```\n\n* **5 建立一个Solver**\n```Lua\ncriterion=nn.ClassNLLCriterion()----使用negatice log--likehood criterion ,即计算cross-entropy损失\n----注意！Torch中训练数据的Label应该从1开始，比如有四类样本，那么label应该是1、2、3、4，不能从0开始，否则报错\ntrainer=nn.StochasticGradient(net,criterion)----使用随机梯度下降\ntrainer.learningRate=0.001----设置solver参数\ntrainer.maxIteration=10----迭代epoch数\n```\n* **6 将net、criterion、trainset和testset移动到GPU中**\n  如果要使用GPU加速，net、criterion、trainset和testset都需要移动到CPU内存中去\n```Lua\ntrainset.data=trainset.data:cuda()\ntrainset.label=trainset.label:cuda()\ntestset.label=trainset.label:cuda()\ntestset.data=testset.data:cuda()\ncriterion=criterion:cuda()\nnet=net:cuda()\n```\n以trainset为例，移动到GPU之后是形式如下的对象\n>{\n  data : CudaTensor - size: 10500x3x24x24x24\n  size : function: 0x42832ef0\n  label : CudaTensor - size: 10500x1\n}\n\n* **7 训练并测试网络**\n有了上面的准备，网络的训练十分简单：\n```Lua\ntrainer:train(trainset)\n```\n>训练过程中输出如下：\nOut[18]:StochasticGradient: training    \nOut[18]:current error = 1.9459465204875 \nOut[18]:current error = 1.941716547001  \nOut[18]:current error = 1.921697193475  \nOut[18]:current error = 1.8641934820811 \nOut[18]:current error = 1.5424795499416 \nOut[18]:current error = 1.3549344599815 \nOut[18]:current error = 1.2374953328995 \nOut[18]:current error = 1.152671923592  \nOut[18]:current error = 1.094293069022  \nOut[18]:current error = 1.0469601832571 \nStochasticGradient: you have reached the maximum number of iterations   \ntraining error = 1.0469601832571\n\n由于设置的最大epoch是10，所以在对trainset迭代了10次之后训练就结束了，接下来是网络的测试：\n```Lua\ncorrect = 0\nfor i=1,3500 do ----我的测试集有3500个cube\n    local groundtruth = testset.label[i][1]\n    local prediction = net:forward(testset.data[i])\n    local confidences, indices = torch.sort(prediction, true)\n    if groundtruth == indices[1] then\n       correct = correct + 1 \n    end\nend\nprint(correct, 100*correct/3500 .. ' % ')\n```\n\n\n### 2. 总结\n使用Torch训练过程包括数据载入，网络定义，trainer定义，训练、测试几个部分，如果使用GPU加速，要将数据等对象移动到GPU中。\n","source":"_posts/在torch中使用cuda进行训练.md","raw":"title: 在torch中使用cuda进行训练\ndate: 2015-12-29 15:50:33\ntags: [机器学习,Torch]\n---\n### 0. 说明\n本文介绍**hdf5文件的读取**、**网络的定义**与**训练**和**测试**，并强调了如何使用**cuda**对网络的训练、测试进行加速。\n### 1. 过程与代码\n* **1 安装hdf5** \n按照[官方tutorial](https://github.com/deepmind/torch-hdf5/blob/master/doc/usage.md)安装torch对hdf5格式文件的支持。\n* **2 引入必要 package 并读入hdf5数据**\n```Lua\n  require 'torch';----如果是在itorch或itorch notbook中自动引入torch\n  require 'hdf5';----hdf5支持\n  require 'nn'; ----neural network modules 的实现\n  require 'cutorch';----cuda backend支持\n  require 'cunn';----neural network modules的cuda实现\n```\n  下面读入数据，假设train和test数据都是按照我[上篇文章](http://withwsf.github.io/2015/12/23/torch-hdf5/)的格式所存储：\n```Lua\nmyFiletrian=hdf5.open('mytrain.h5','r')----读取hdf5文件\nmyFiletest=hdf5.open('mytest.h5','r')\n----将读入的hdf5存到两个Table： trainset和testset中\ntrainset={data=myFiletrian:read('data'):all(),label=myFiletrian:read('label'):all():byte()}\ntestset={data=myFiletest:read('data'):all(),label=myFiletest:read('label'):all():byte()}\n```\n* **3 重载trainset的_index操作符并添加成员函数size()**\n  Lua中也存在面向对象的概念，Lua中的类可以通过Table+function模拟出来。这里将trainset视作一个类的对象，torch要求这个类有方法trainset:size()可以返回样本个数，使用操作符trainset[i]时返回第i个样本。\n```Lua\nsetmetatable(trainset, ----重载index操作符\n    {__index = function(t, i) \n                    return {t.data[i], t.label[i]} \n                end}\n);\n\nfunction trainset:size()----添加成员函数 size()\n    return self.data:size(1)\nend\n```\n* **4 建立一个网络**\n  我使用Torch的主要原因是因为Torch有3D conv模块，所以这里以模仿**LeNet**的3D conv网络为例：\n```Lua\nnet=nn.Sequential()\nnet:add(nn.VolumetricConvolution(3,5,3,3,3))----添加3D conv层，输入3个feature cube，输出5个feature cube，filter size为3*3*3\nnet:add(nn.VolumetricMaxPooling(2,2,2,2,2,2))----添加3D MaxPooling层\nnet:add(nn.VolumetricConvolution(5,16,4,4,4))\nnet:add(nn.VolumetricMaxPooling(2,2,2,2,2,2))\nnet:add(nn.View(16*4*4*4))----连接全连接层之前要使用nn.View()进行reshpe，nn.View()里面的参数需要根据\n---（接上）数据的尺寸和前面的层来计算，比如在这里我是用的训练数据是3*24*24*24的cube,分别经过3*3*3和4*4*4 filter尺寸的两次卷积和两次maxpooling之后最终的输出是16个4*4*4*的feature cube ，那么nn.View()里面的参数就应该是16*4*4*4\nnet:add(nn.Linear(16*4*4*4,120))\nnet:add(nn.Linear(120,84))----nn.Linear(a,b)，设置a个输入neurons和b个输出neurons的全全连接层\nnet:add(nn.Linear(84,7))\nnet:add(nn.LogSoftMax())-----输出每个类别概率P的log函数值log(P)\n\n```\n\n* **5 建立一个Solver**\n```Lua\ncriterion=nn.ClassNLLCriterion()----使用negatice log--likehood criterion ,即计算cross-entropy损失\n----注意！Torch中训练数据的Label应该从1开始，比如有四类样本，那么label应该是1、2、3、4，不能从0开始，否则报错\ntrainer=nn.StochasticGradient(net,criterion)----使用随机梯度下降\ntrainer.learningRate=0.001----设置solver参数\ntrainer.maxIteration=10----迭代epoch数\n```\n* **6 将net、criterion、trainset和testset移动到GPU中**\n  如果要使用GPU加速，net、criterion、trainset和testset都需要移动到CPU内存中去\n```Lua\ntrainset.data=trainset.data:cuda()\ntrainset.label=trainset.label:cuda()\ntestset.label=trainset.label:cuda()\ntestset.data=testset.data:cuda()\ncriterion=criterion:cuda()\nnet=net:cuda()\n```\n以trainset为例，移动到GPU之后是形式如下的对象\n>{\n  data : CudaTensor - size: 10500x3x24x24x24\n  size : function: 0x42832ef0\n  label : CudaTensor - size: 10500x1\n}\n\n* **7 训练并测试网络**\n有了上面的准备，网络的训练十分简单：\n```Lua\ntrainer:train(trainset)\n```\n>训练过程中输出如下：\nOut[18]:StochasticGradient: training    \nOut[18]:current error = 1.9459465204875 \nOut[18]:current error = 1.941716547001  \nOut[18]:current error = 1.921697193475  \nOut[18]:current error = 1.8641934820811 \nOut[18]:current error = 1.5424795499416 \nOut[18]:current error = 1.3549344599815 \nOut[18]:current error = 1.2374953328995 \nOut[18]:current error = 1.152671923592  \nOut[18]:current error = 1.094293069022  \nOut[18]:current error = 1.0469601832571 \nStochasticGradient: you have reached the maximum number of iterations   \ntraining error = 1.0469601832571\n\n由于设置的最大epoch是10，所以在对trainset迭代了10次之后训练就结束了，接下来是网络的测试：\n```Lua\ncorrect = 0\nfor i=1,3500 do ----我的测试集有3500个cube\n    local groundtruth = testset.label[i][1]\n    local prediction = net:forward(testset.data[i])\n    local confidences, indices = torch.sort(prediction, true)\n    if groundtruth == indices[1] then\n       correct = correct + 1 \n    end\nend\nprint(correct, 100*correct/3500 .. ' % ')\n```\n\n\n### 2. 总结\n使用Torch训练过程包括数据载入，网络定义，trainer定义，训练、测试几个部分，如果使用GPU加速，要将数据等对象移动到GPU中。\n","slug":"在torch中使用cuda进行训练","published":1,"updated":"2016-11-29T13:47:45.944Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw3lgiv20008wsgsopaqqxvo"},{"title":"在Windows中阅读Caffe代码","date":"2016-05-23T07:50:33.000Z","_content":"#### 前言\n我们都知道世界上最好的IDE是Visual Studio，如果能用VS来调试、阅读Caffe的代码，观察Caffe运行过程，相信理解的效率会大大提高，但将Caffe移植到Windows上非常耗时耗力。\n最近微软官方发布了Caffe的Windows branch，使用Nuget自动下载配置Caffe各种依赖，使得Caffe在Windows下的安装运行比在原生的Linux环境下更加简单。本文勾勒一下从安装到调试运行的大致步骤，希望能对后来者有帮助。\n#### Caffe的安装\n* 安装Visual Studio 2013\n* [下载](https://github.com/BVLC/caffe/tree/windows)Windows branch的git文件，并按照README.md中的指导进行安装(如果不使用CUDA，记得按照指导修改“CommonSettings.props”文件)。\n#### 调试与运行\n* 第一次进行编译时Nuget会自动下载大约1G大小的依赖，请耐心等待，如果编译过程中出现“**错误\t8559\terror C2220: 警告被视为错误...**”，请参考[fisherman](http://115.29.54.164/?/question/281#!answer_form)的解决方法。\n* 首次编译成功后，鼠标右击classfication项目，之后单击\"Set as StartUp Project\"选项，设置程序的启动项目\n ![修改启动项目](http://img.blog.csdn.net/20160523200739474)\n* 接着进入classfication项目的classfication.cpp文件中，拉到最下面，找到main函数，修改代码，在代码中指定模型、图片等文件的路径。然后设置断点，就可以可使用VS强大的调试功能一步步观察Caffe的运行过程了。\n\n![修改main函数](http://img.blog.csdn.net/20160523202031729)\n","source":"_posts/在Windows阅读Caffe代码.md","raw":"title: 在Windows中阅读Caffe代码\ndate: 2016-05-23 15:50:33\ntags: [机器学习,Caffe]\n---\n#### 前言\n我们都知道世界上最好的IDE是Visual Studio，如果能用VS来调试、阅读Caffe的代码，观察Caffe运行过程，相信理解的效率会大大提高，但将Caffe移植到Windows上非常耗时耗力。\n最近微软官方发布了Caffe的Windows branch，使用Nuget自动下载配置Caffe各种依赖，使得Caffe在Windows下的安装运行比在原生的Linux环境下更加简单。本文勾勒一下从安装到调试运行的大致步骤，希望能对后来者有帮助。\n#### Caffe的安装\n* 安装Visual Studio 2013\n* [下载](https://github.com/BVLC/caffe/tree/windows)Windows branch的git文件，并按照README.md中的指导进行安装(如果不使用CUDA，记得按照指导修改“CommonSettings.props”文件)。\n#### 调试与运行\n* 第一次进行编译时Nuget会自动下载大约1G大小的依赖，请耐心等待，如果编译过程中出现“**错误\t8559\terror C2220: 警告被视为错误...**”，请参考[fisherman](http://115.29.54.164/?/question/281#!answer_form)的解决方法。\n* 首次编译成功后，鼠标右击classfication项目，之后单击\"Set as StartUp Project\"选项，设置程序的启动项目\n ![修改启动项目](http://img.blog.csdn.net/20160523200739474)\n* 接着进入classfication项目的classfication.cpp文件中，拉到最下面，找到main函数，修改代码，在代码中指定模型、图片等文件的路径。然后设置断点，就可以可使用VS强大的调试功能一步步观察Caffe的运行过程了。\n\n![修改main函数](http://img.blog.csdn.net/20160523202031729)\n","slug":"在Windows阅读Caffe代码","published":1,"updated":"2016-11-29T13:47:45.941Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw3lgiv4000dwsgscbat7nnu"},{"title":"为Torch创建hdf5训练文件","date":"2015-12-23T14:13:02.000Z","_content":"### 1. Torch与HDF5\n**[Torch](http://torch.ch)** 是用**C/CUDA**作为底层实现，用**LuaJIT**作为接口的机器学习算法框架。\n\n**[HDF5](http://docs.h5py.org/en/latest/quick.html)**是用于海量复杂数据集管理的技术,能够支持多种平台与多种语言接口（C，C++，Python等）。\n\nTorch的tutorial只提供了处理images和random tensors的方法，并没有对其他格式提供示例。本文使用将对如何创建HDF5数据集以及如何在Torch中使用HDF5文件格式做一个梳理。\n\n### 2. 使用Python创建HDF5文件\n* **1  在Python中安装 h5py**\n在Ubuntu下 `sudo pip install h5py`\n\n* **2  创建HDF5对象**\n我们需要的HDF5文件在root (group) 下应该有“data”和“label”两个dataset，并在创建时指定这两个dataset的尺寸。\n``` python\nimport h5py, os                             \nf=h5py.File('train.h5','w') #以'w'模式创建一个名为'train.h5'的HDF5对象\nf.create_dataset('data',(100,3,32,32),dtype='f8') #有100个样本，每个样本有三个channel，每个channle的尺寸是32*32\nf.create_dataset('label',(100,1),dtype='i') #创建存放label的dataset，尺寸是100*1\n```\n\n* **3 写入数据**\n写入数据其实很简单，只需要对dataset中的每个对象赋值即可。我们使用numpy随机生成的数据为例进行赋值。\n```python\nimport numpy as np\nfor i in range(100):\n  temp=np.random.random((3,32,32))\n  f['data'][i]=temp #写入data\n  f['label'][i]=i%4 #写入label\nf.close()\n \n```\n以上，即可生成一个用于训练的train.hdf5文件。\n### 3. 在torch中使用HDF5文件\n在torch中读取HDF5文件需要用到**torch-hdf5**,可以参照[官方文档来安装](https://github.com/deepmind/torch-hdf5/blob/master/doc/usage.md)。\n```lua\nrequire 'hdf5';\nmyFile=hdf5.open('path_to_hdf5_file','r') -- 读入HDF5文件\ntrainset={data=myFile:read('data'):all(),label=myFile:read('label'):all():byte()}\n```\ntrainset是与[官方tutorial](https://github.com/soumith/cvpr2015/blob/master/Deep%20Learning%20with%20Torch.ipynb)读取'cifar10-train.t7' 后同样的对象。\n``` lua\ntrainset --输入trainset并执行后可以看到trainset的信息如下\n ----------------执行输出的信息-------------------------------------------------\n｛\ndata : DoubleTensor - size: 100×3×32×32\nlabel : ByteTensor -size: 100×1\n｝\n```\n\n\n\n**按照上述的方法创建trainset和testset并读取数据之后，就接着可以进行训练了，由于内容不在本文范围内，所以略过。**\n","source":"_posts/torch-hdf5.md","raw":"title: 为Torch创建hdf5训练文件\ndate: 2015-12-23 22:13:02\ntags: [机器学习,Torch]\n---\n### 1. Torch与HDF5\n**[Torch](http://torch.ch)** 是用**C/CUDA**作为底层实现，用**LuaJIT**作为接口的机器学习算法框架。\n\n**[HDF5](http://docs.h5py.org/en/latest/quick.html)**是用于海量复杂数据集管理的技术,能够支持多种平台与多种语言接口（C，C++，Python等）。\n\nTorch的tutorial只提供了处理images和random tensors的方法，并没有对其他格式提供示例。本文使用将对如何创建HDF5数据集以及如何在Torch中使用HDF5文件格式做一个梳理。\n\n### 2. 使用Python创建HDF5文件\n* **1  在Python中安装 h5py**\n在Ubuntu下 `sudo pip install h5py`\n\n* **2  创建HDF5对象**\n我们需要的HDF5文件在root (group) 下应该有“data”和“label”两个dataset，并在创建时指定这两个dataset的尺寸。\n``` python\nimport h5py, os                             \nf=h5py.File('train.h5','w') #以'w'模式创建一个名为'train.h5'的HDF5对象\nf.create_dataset('data',(100,3,32,32),dtype='f8') #有100个样本，每个样本有三个channel，每个channle的尺寸是32*32\nf.create_dataset('label',(100,1),dtype='i') #创建存放label的dataset，尺寸是100*1\n```\n\n* **3 写入数据**\n写入数据其实很简单，只需要对dataset中的每个对象赋值即可。我们使用numpy随机生成的数据为例进行赋值。\n```python\nimport numpy as np\nfor i in range(100):\n  temp=np.random.random((3,32,32))\n  f['data'][i]=temp #写入data\n  f['label'][i]=i%4 #写入label\nf.close()\n \n```\n以上，即可生成一个用于训练的train.hdf5文件。\n### 3. 在torch中使用HDF5文件\n在torch中读取HDF5文件需要用到**torch-hdf5**,可以参照[官方文档来安装](https://github.com/deepmind/torch-hdf5/blob/master/doc/usage.md)。\n```lua\nrequire 'hdf5';\nmyFile=hdf5.open('path_to_hdf5_file','r') -- 读入HDF5文件\ntrainset={data=myFile:read('data'):all(),label=myFile:read('label'):all():byte()}\n```\ntrainset是与[官方tutorial](https://github.com/soumith/cvpr2015/blob/master/Deep%20Learning%20with%20Torch.ipynb)读取'cifar10-train.t7' 后同样的对象。\n``` lua\ntrainset --输入trainset并执行后可以看到trainset的信息如下\n ----------------执行输出的信息-------------------------------------------------\n｛\ndata : DoubleTensor - size: 100×3×32×32\nlabel : ByteTensor -size: 100×1\n｝\n```\n\n\n\n**按照上述的方法创建trainset和testset并读取数据之后，就接着可以进行训练了，由于内容不在本文范围内，所以略过。**\n","slug":"torch-hdf5","published":1,"updated":"2016-11-29T13:47:45.939Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw3lgiv7000hwsgstlqiljt3"},{"title":"深度学习实用策略","date":"2016-04-22T17:44:36.000Z","_content":"本文翻译自DeepLearning balabala\n\n#### 引言\n要想在实际生产中应用深度学习技术，仅仅知道算法的公式与原理是远远不够的。优秀的数据工作者需要能够根据特定的应用选择合适的算法，并能够根据实验过程中算法的反馈信息不断进行优化——是收集更多的数据，还是增加模型的复杂度，或者改变数据预处理方法，抑或是对程序进行调试等等。所有这些优化方法都需要耗费大量时间，没有方向性地乱撞显然是行不通的，需要有一些通用的、原则性的指导。\n\n机器学习领域有各式各样的模型、训练算法与目标函数，这会给人一种“错觉”，对机器学习专家来说最重要的是掌握各式各样的机器学习技法和各个相关领域的数学知识。实际上，如果使用恰当，即使是烂大街的普通算法，也要比马马虎虎、一知半解使用的“高级”算法效果要好很多。而正确地使用算法很简单，掌握一些很简单的原则与策略就足够了。下面是推荐的机器学习系统设计流程：\n\n* 决定目标——首先要明确算法的性能衡量指标(原文是error metric)，以及要将这个衡量指标优化到什么程度。\n* 尽快建立end to end的pipeline，包括恰当地估计性能指标。\n* 找出系统的瓶颈，并有针对性优化。找出系统的哪个部分表现低于预期并分析原因——是因为过拟合还是因为欠拟合，还是数据或或代码出了问题。\n* 不断地进行增量式调整——比如收集新的数据或者调整先验参数，甚至更换算法。\n\n为了详细介绍上述的流程，将使用经典的街景门牌号识别系统为例进行说明。街景车能拍下建筑的门牌号并记录拍摄时的位置，该系统识别图片中的门牌号，并在谷歌地图中的相应位置更新信息。相信随着读者一步步了解这个成功的商业应用系统是如何构建的，可以加深对上面提到的设计流程的理解。\n#### 性能衡量指标\n决定系统的性能衡量指标（即error metric）是相当重要的第一步，因为后续所有的工作都是围绕着这个指标进行的。另外，也要对系统的性能要达到何种程度做到心中有数。\n\n系统的性能衡量指标跟算法要优化的损失函数多数情况下并不相同，比如简单二分类问题，损失函数可以是LR中交叉熵损失、后者SVM中使用hinge loss，或者是简单的感知机使用的0-1损失，但是我们对算法的性能衡量指标却可能是查全率、查准率或者是综合考虑查全率与查准率的.....。\n\n需要明确的是，绝大多数系统都是做不到没有任何错误的。即使你有无限的多的训练数据而且能恢复真实的概率分布，也突破不了贝叶斯错误（Bayes error）的下界。因为特征含有的信息可能相对于输出变量来说并不完全(比如只知道)，或者系统本身就含有随机性。何况获取无限的训练数据也是不可能的。\n\n训练数据的多少受到多种因素的制约。实际的应用存在训练数据量与性能的trade-off，收集数据是需要付出代价的，时间、金钱、人力都需要考虑，需要在数据量增加带来的受益与收集数据付出的成本之间进行权衡。如果目的是偏学术性的，要衡量不同算法的性能，那么使用的训练与测试数据是公认的benchmark，是不能够对数据随便进行更改的。\n\n如何决定要将衡量指标优化到什么程度呢？如果是学术研究的话，至少要比当前的其他算法性能要好后者差不多吧，否则也没有意义。实际商业应用的话，考虑的因素就多一些，","source":"_posts/dl-practical-methodolog.md","raw":"title: 深度学习实用策略\ndate: 2016-04-23 01:44:36\ntags: [深度学习]\n---\n本文翻译自DeepLearning balabala\n\n#### 引言\n要想在实际生产中应用深度学习技术，仅仅知道算法的公式与原理是远远不够的。优秀的数据工作者需要能够根据特定的应用选择合适的算法，并能够根据实验过程中算法的反馈信息不断进行优化——是收集更多的数据，还是增加模型的复杂度，或者改变数据预处理方法，抑或是对程序进行调试等等。所有这些优化方法都需要耗费大量时间，没有方向性地乱撞显然是行不通的，需要有一些通用的、原则性的指导。\n\n机器学习领域有各式各样的模型、训练算法与目标函数，这会给人一种“错觉”，对机器学习专家来说最重要的是掌握各式各样的机器学习技法和各个相关领域的数学知识。实际上，如果使用恰当，即使是烂大街的普通算法，也要比马马虎虎、一知半解使用的“高级”算法效果要好很多。而正确地使用算法很简单，掌握一些很简单的原则与策略就足够了。下面是推荐的机器学习系统设计流程：\n\n* 决定目标——首先要明确算法的性能衡量指标(原文是error metric)，以及要将这个衡量指标优化到什么程度。\n* 尽快建立end to end的pipeline，包括恰当地估计性能指标。\n* 找出系统的瓶颈，并有针对性优化。找出系统的哪个部分表现低于预期并分析原因——是因为过拟合还是因为欠拟合，还是数据或或代码出了问题。\n* 不断地进行增量式调整——比如收集新的数据或者调整先验参数，甚至更换算法。\n\n为了详细介绍上述的流程，将使用经典的街景门牌号识别系统为例进行说明。街景车能拍下建筑的门牌号并记录拍摄时的位置，该系统识别图片中的门牌号，并在谷歌地图中的相应位置更新信息。相信随着读者一步步了解这个成功的商业应用系统是如何构建的，可以加深对上面提到的设计流程的理解。\n#### 性能衡量指标\n决定系统的性能衡量指标（即error metric）是相当重要的第一步，因为后续所有的工作都是围绕着这个指标进行的。另外，也要对系统的性能要达到何种程度做到心中有数。\n\n系统的性能衡量指标跟算法要优化的损失函数多数情况下并不相同，比如简单二分类问题，损失函数可以是LR中交叉熵损失、后者SVM中使用hinge loss，或者是简单的感知机使用的0-1损失，但是我们对算法的性能衡量指标却可能是查全率、查准率或者是综合考虑查全率与查准率的.....。\n\n需要明确的是，绝大多数系统都是做不到没有任何错误的。即使你有无限的多的训练数据而且能恢复真实的概率分布，也突破不了贝叶斯错误（Bayes error）的下界。因为特征含有的信息可能相对于输出变量来说并不完全(比如只知道)，或者系统本身就含有随机性。何况获取无限的训练数据也是不可能的。\n\n训练数据的多少受到多种因素的制约。实际的应用存在训练数据量与性能的trade-off，收集数据是需要付出代价的，时间、金钱、人力都需要考虑，需要在数据量增加带来的受益与收集数据付出的成本之间进行权衡。如果目的是偏学术性的，要衡量不同算法的性能，那么使用的训练与测试数据是公认的benchmark，是不能够对数据随便进行更改的。\n\n如何决定要将衡量指标优化到什么程度呢？如果是学术研究的话，至少要比当前的其他算法性能要好后者差不多吧，否则也没有意义。实际商业应用的话，考虑的因素就多一些，","slug":"dl-practical-methodolog","published":1,"updated":"2016-11-29T13:47:45.936Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw3lgiva000kwsgstfjf9lci"},{"title":"Python在Windows环境下处理文件路径问题最佳实践","date":"2015-12-30T06:45:38.000Z","_content":"Windows中路径分隔符是反斜线'\\'，而在Python中'\\'又有转义符的作用，因而直接从windows资源管理器复制的路径在Python中是不能正常识别的。\n\n* **最优实践：**\n使用os.path.join来join不同的路径，比如\n```Python\npath=os.path.join(dirpath,filepath)\n```\n也可以使用os.sep，python会根据不同的系统自动选择合适的路径分隔符\n```python\npath=dirpath+os.sep+filepath\n```\n* **次优方案**\n可以将所有路径都使用正斜线'/'，不管在Windows和Linux中都适用.\n* **不要使用**\n在引用的字符串前面加上'r'可以将转义字符串(escaped strings )转换为原始字符串(raw strings)，可以解决部分问题。比如：\n```python\nfile=open('c:\\myfile') #打开错误\nfile=open(r'c:\\myfile')#可以正确打开\n```\n但是'r'是为了方便书写正则表达式而不是为了解决Windows下文件路径问题而设计的特性，所以会遇到一下问题\n\n>file=open(r'c:\\dir\\'+'myfile')\n\n上述代码是错误的，虽然'\\'失去了转义作用，但仍然有保护作用，其后的‘'’并不会被视为closing delimiter。\n\n\n由此可见，使用r不仅没有完全解决问题，还会引入新的问题，所以最好不要使用。\n\n","source":"_posts/Python在Windows环境下处理文件路径问题最佳实践.md","raw":"title: Python在Windows环境下处理文件路径问题最佳实践\ndate: 2015-12-30 14:45:38\ntags: [Python]\n---\nWindows中路径分隔符是反斜线'\\'，而在Python中'\\'又有转义符的作用，因而直接从windows资源管理器复制的路径在Python中是不能正常识别的。\n\n* **最优实践：**\n使用os.path.join来join不同的路径，比如\n```Python\npath=os.path.join(dirpath,filepath)\n```\n也可以使用os.sep，python会根据不同的系统自动选择合适的路径分隔符\n```python\npath=dirpath+os.sep+filepath\n```\n* **次优方案**\n可以将所有路径都使用正斜线'/'，不管在Windows和Linux中都适用.\n* **不要使用**\n在引用的字符串前面加上'r'可以将转义字符串(escaped strings )转换为原始字符串(raw strings)，可以解决部分问题。比如：\n```python\nfile=open('c:\\myfile') #打开错误\nfile=open(r'c:\\myfile')#可以正确打开\n```\n但是'r'是为了方便书写正则表达式而不是为了解决Windows下文件路径问题而设计的特性，所以会遇到一下问题\n\n>file=open(r'c:\\dir\\'+'myfile')\n\n上述代码是错误的，虽然'\\'失去了转义作用，但仍然有保护作用，其后的‘'’并不会被视为closing delimiter。\n\n\n由此可见，使用r不仅没有完全解决问题，还会引入新的问题，所以最好不要使用。\n\n","slug":"Python在Windows环境下处理文件路径问题最佳实践","published":1,"updated":"2016-11-29T13:47:45.934Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw3lgivj000nwsgs92uz4yd8"},{"title":"Caffe中的Net类是如何工作的","date":"2016-05-24T12:21:47.000Z","_content":"Net类是Caffe中Blobs，Layers，Nets三个抽象层次中最高层的抽象。Nets类负责按照网络定义文件将需要的layers和中间blobs进行实例化，并将所有的Layers组合成一个有向无环图。Nets还提供了在整个网络上进行前向传播与后向传播的接口。下面从观察Net运行的角度来解析一下Net类如何工作。\n### Net类数据成员概述\n**下面对Net类中比较重要的数据成员进行说明：**\n\n* **`vector<shared_ptr<Layer<Dtype> > > layers_;`**\nlayers_中存放着网络的所有layers，也就是Net类的实例保存着网络定义文件中所有layer的实例\n\n* **`vector<shared_ptr<Blob<Dtype> > > blobs_;`**\nblobs_中保存着网络所有的中间结果，即所有layer的输入数据（bottom blob）和输出数据（top blob）\n\n* **`vector<vector<Blob<Dtype>*> > bottom_vecs_;`**\n* **`vector<vector<Blob<Dtype>*> > top_vecs_;`**  \n`bottom_vecs_`保存的是各个layer的bottom blob的指针，这些指针指向`blobs_`中的blob。`bottom_ves.size()`与网络layer的数量相等，由于layer可能有多个bottom blob，所以使用`vector<Blob<Dtype>*>`来存放layer-wise的bottom blob。同理可以知道`top_vecs`的作用。\n\n* **`vector<shared_ptr<Blob<Dtype> > > params_;`**\n* **`vector<Blob<Dtype>*> learnable_params_;`**\n上述两个数据成员存放的是指向网络参数的指针，注意，直接拥有参数的是layer，`params_`保存的只是网络中各个layer的参数的指针；而`learnable_params_`也如其名字所指，保存的是各个layer中可以被学习的参数。\n\n\n### Net类的实例化(一个网络的建立)\n#### 构造函数\nNet类有两个构造函数，分别是`Net(const NetParameter& param, const Net* root_net)`和`Net(const string& param_file, Phase phase, const Net* root_net)`,前者接受`NetParameter`的const引用作为参数(后面参数root_net与多GPU并行训练有关，忽略掉并不影响理解)，后者接受定义网络prototxt文件路径和`phase`作为输入。\n前者直接调用`Init()`函数，后者将prototxt文件解析为`NetPrameter`后调用`Init()`函数。\n#### Init()函数\n`Init()`函数承担初始化一个网络的任务，摘取主干代码描述如下（忽略细节，大致描述过程）：\n\n```C++\nfor (int layer_id = 0; layer_id < param.layer_size(); ++layer_id) {//param是网络参数，layer_size()返回网络拥有的层数\n    const LayerParameter& layer_param = param.layer(layer_id);//获取当前layer的参数\n    layers_.push_back(LayerRegistry<Dtype>::CreateLayer(layer_param));//根据参数实例化layer\n\n\n//下面的两个for循环将此layer的bottom blob的指针和top blob的指针放入bottom_vecs_和top_vecs_,bottom blob和top blob的实例全都存放在blobs_中。相邻的两层，前一层的top blob是后一层的bottom blob，所以blobs_的同一个blob既可能是bottom blob，也可能使top blob。\n    for (int bottom_id = 0; bottom_id < layer_param.bottom_size();++bottom_id) {\n       const int blob_id=AppendBottom(param,layer_id,bottom_id,&available_blobs,&blob_name_to_idx);\n    }\n\n    for (int top_id = 0; top_id < num_top; ++top_id) {\n       AppendTop(param, layer_id, top_id, &available_blobs, &blob_name_to_idx);\n    }\n\n//接下来的工作是将每层的parameter的指针塞进params_，尤其是learnable_params_。\n   const int num_param_blobs = layers_[layer_id]->blobs().size();\n   for (int param_id = 0; param_id < num_param_blobs; ++param_id) {\n       AppendParam(param, layer_id, param_id);\n       //AppendParam负责具体的dirtywork\n    }\n\n    }\n```\n#### 初始化之后\n经过上述过程的网络，参数都是随机产生或者指定的，如果进行预测或这fine-tuning，就需要将载入预训练的权值，Net类提供的函数`CopyTrainedLayersFrom(const string& trained_file)`可以实现这个过程。\n### 网络的运行(前向传播, 反向传播和权值更新)\nNet类可以提供网络级的前向前向传播、反向传播和权值更新(即在网络的所有层上有序执行前述动作)。\n#### 前向传播\n与前向传播相关的函数有`Forward(const vector<Blob<Dtype>*> & bottom, Dtype* loss)`,`Forward(Dtype* loss)`,`ForwardTo(int end)`，`ForwardFrom(int start)`和`ForwardFromTo(int start, int end)`，前面的四个函数都是对第五个函数封装，第五个函数定义如下：\n    ```\n    template <typename Dtype>\nDtype Net<Dtype>::ForwardFromTo(int start, int end) {\n  CHECK_GE(start, 0);\n  CHECK_LT(end, layers_.size());\n  Dtype loss = 0;\n  for (int i = start; i <= end; ++i) {\n    // LOG(ERROR) << \"Forwarding \" << layer_names_[i];\n    Dtype layer_loss = layers_[i]->Forward(bottom_vecs_[i], top_vecs_[i]);\n    loss += layer_loss;\n    if (debug_info_) { ForwardDebugInfo(i); }\n  }\n  return loss;\n}\n    ```\n    重点语句是`layers_[i]->Forward(bottom_vecs_[i], top_vecs_[i]);`，使用layer对应bottom blob和top blob进行前向传播。\n\n#### 反向传播\n与前向传播一样，反向传播也有很多相关函数，但都是对`BackwardFromTo(int start, int end)`的封装。\n```void Net<Dtype>::BackwardFromTo(int start, int end) {\n  CHECK_GE(end, 0);\n  CHECK_LT(start, layers_.size());\n  for (int i = start; i >= end; --i) {\n    if (layer_need_backward_[i]) {\n      layers_[i]->Backward(top_vecs_[i], bottom_need_backward_[i], bottom_vecs_[i]);\n      if (debug_info_) { BackwardDebugInfo(i); }\n    }\n  }\n}\n```\n与前向传播相反，反向传播是从尾到头进行的。\n#### 权值更新\n\n```\ntemplate <typename Dtype>\nvoid Net<Dtype>::Update() {\n  for (int i = 0; i < learnable_params_.size(); ++i) {\n    learnable_params_[i]->Update();\n  }\n}\n```\n在训练的过程中layer的权值要根据反向传播并累积的梯度进行更新，更新的过程由`Update()`完成。这个函数的功能十分明确，对每个存储learnable_parms的blob调用blob的`Update()`函数，来更新权值。\n","source":"_posts/Caffe中的Net类是如何工作的.md","raw":"title: Caffe中的Net类是如何工作的\ndate: 2016-05-24 20:21:47\ntags: [C++,Caffe]\n---\nNet类是Caffe中Blobs，Layers，Nets三个抽象层次中最高层的抽象。Nets类负责按照网络定义文件将需要的layers和中间blobs进行实例化，并将所有的Layers组合成一个有向无环图。Nets还提供了在整个网络上进行前向传播与后向传播的接口。下面从观察Net运行的角度来解析一下Net类如何工作。\n### Net类数据成员概述\n**下面对Net类中比较重要的数据成员进行说明：**\n\n* **`vector<shared_ptr<Layer<Dtype> > > layers_;`**\nlayers_中存放着网络的所有layers，也就是Net类的实例保存着网络定义文件中所有layer的实例\n\n* **`vector<shared_ptr<Blob<Dtype> > > blobs_;`**\nblobs_中保存着网络所有的中间结果，即所有layer的输入数据（bottom blob）和输出数据（top blob）\n\n* **`vector<vector<Blob<Dtype>*> > bottom_vecs_;`**\n* **`vector<vector<Blob<Dtype>*> > top_vecs_;`**  \n`bottom_vecs_`保存的是各个layer的bottom blob的指针，这些指针指向`blobs_`中的blob。`bottom_ves.size()`与网络layer的数量相等，由于layer可能有多个bottom blob，所以使用`vector<Blob<Dtype>*>`来存放layer-wise的bottom blob。同理可以知道`top_vecs`的作用。\n\n* **`vector<shared_ptr<Blob<Dtype> > > params_;`**\n* **`vector<Blob<Dtype>*> learnable_params_;`**\n上述两个数据成员存放的是指向网络参数的指针，注意，直接拥有参数的是layer，`params_`保存的只是网络中各个layer的参数的指针；而`learnable_params_`也如其名字所指，保存的是各个layer中可以被学习的参数。\n\n\n### Net类的实例化(一个网络的建立)\n#### 构造函数\nNet类有两个构造函数，分别是`Net(const NetParameter& param, const Net* root_net)`和`Net(const string& param_file, Phase phase, const Net* root_net)`,前者接受`NetParameter`的const引用作为参数(后面参数root_net与多GPU并行训练有关，忽略掉并不影响理解)，后者接受定义网络prototxt文件路径和`phase`作为输入。\n前者直接调用`Init()`函数，后者将prototxt文件解析为`NetPrameter`后调用`Init()`函数。\n#### Init()函数\n`Init()`函数承担初始化一个网络的任务，摘取主干代码描述如下（忽略细节，大致描述过程）：\n\n```C++\nfor (int layer_id = 0; layer_id < param.layer_size(); ++layer_id) {//param是网络参数，layer_size()返回网络拥有的层数\n    const LayerParameter& layer_param = param.layer(layer_id);//获取当前layer的参数\n    layers_.push_back(LayerRegistry<Dtype>::CreateLayer(layer_param));//根据参数实例化layer\n\n\n//下面的两个for循环将此layer的bottom blob的指针和top blob的指针放入bottom_vecs_和top_vecs_,bottom blob和top blob的实例全都存放在blobs_中。相邻的两层，前一层的top blob是后一层的bottom blob，所以blobs_的同一个blob既可能是bottom blob，也可能使top blob。\n    for (int bottom_id = 0; bottom_id < layer_param.bottom_size();++bottom_id) {\n       const int blob_id=AppendBottom(param,layer_id,bottom_id,&available_blobs,&blob_name_to_idx);\n    }\n\n    for (int top_id = 0; top_id < num_top; ++top_id) {\n       AppendTop(param, layer_id, top_id, &available_blobs, &blob_name_to_idx);\n    }\n\n//接下来的工作是将每层的parameter的指针塞进params_，尤其是learnable_params_。\n   const int num_param_blobs = layers_[layer_id]->blobs().size();\n   for (int param_id = 0; param_id < num_param_blobs; ++param_id) {\n       AppendParam(param, layer_id, param_id);\n       //AppendParam负责具体的dirtywork\n    }\n\n    }\n```\n#### 初始化之后\n经过上述过程的网络，参数都是随机产生或者指定的，如果进行预测或这fine-tuning，就需要将载入预训练的权值，Net类提供的函数`CopyTrainedLayersFrom(const string& trained_file)`可以实现这个过程。\n### 网络的运行(前向传播, 反向传播和权值更新)\nNet类可以提供网络级的前向前向传播、反向传播和权值更新(即在网络的所有层上有序执行前述动作)。\n#### 前向传播\n与前向传播相关的函数有`Forward(const vector<Blob<Dtype>*> & bottom, Dtype* loss)`,`Forward(Dtype* loss)`,`ForwardTo(int end)`，`ForwardFrom(int start)`和`ForwardFromTo(int start, int end)`，前面的四个函数都是对第五个函数封装，第五个函数定义如下：\n    ```\n    template <typename Dtype>\nDtype Net<Dtype>::ForwardFromTo(int start, int end) {\n  CHECK_GE(start, 0);\n  CHECK_LT(end, layers_.size());\n  Dtype loss = 0;\n  for (int i = start; i <= end; ++i) {\n    // LOG(ERROR) << \"Forwarding \" << layer_names_[i];\n    Dtype layer_loss = layers_[i]->Forward(bottom_vecs_[i], top_vecs_[i]);\n    loss += layer_loss;\n    if (debug_info_) { ForwardDebugInfo(i); }\n  }\n  return loss;\n}\n    ```\n    重点语句是`layers_[i]->Forward(bottom_vecs_[i], top_vecs_[i]);`，使用layer对应bottom blob和top blob进行前向传播。\n\n#### 反向传播\n与前向传播一样，反向传播也有很多相关函数，但都是对`BackwardFromTo(int start, int end)`的封装。\n```void Net<Dtype>::BackwardFromTo(int start, int end) {\n  CHECK_GE(end, 0);\n  CHECK_LT(start, layers_.size());\n  for (int i = start; i >= end; --i) {\n    if (layer_need_backward_[i]) {\n      layers_[i]->Backward(top_vecs_[i], bottom_need_backward_[i], bottom_vecs_[i]);\n      if (debug_info_) { BackwardDebugInfo(i); }\n    }\n  }\n}\n```\n与前向传播相反，反向传播是从尾到头进行的。\n#### 权值更新\n\n```\ntemplate <typename Dtype>\nvoid Net<Dtype>::Update() {\n  for (int i = 0; i < learnable_params_.size(); ++i) {\n    learnable_params_[i]->Update();\n  }\n}\n```\n在训练的过程中layer的权值要根据反向传播并累积的梯度进行更新，更新的过程由`Update()`完成。这个函数的功能十分明确，对每个存储learnable_parms的blob调用blob的`Update()`函数，来更新权值。\n","slug":"Caffe中的Net类是如何工作的","published":1,"updated":"2016-11-29T13:47:45.932Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw3lgivm000qwsgsiq87w8wv"},{"title":"在Caffe中使用Python Layer","date":"2016-04-14T03:10:01.000Z","_content":"\n#### Caffe通过Boost中的Boost.Python模块来支持使用Python定义Layer：\n\n* 使用C++增加新的Layer**繁琐**、**耗时**而且很容易**出错**\n* **开发速度**与**执行速度**之间的**trade-off**\n\n\n#### 编译支持Python Layer的Caffe\n\n如果是首次编译，修改Caffe根目录下的Makefile.cinfig，uncomment\n```\nWITH_PYTHON_LAYER:=1\n```\n 如果已经编译过\n```\nmake clean\nWITH_PYTHON_LAYER=1 make&& make pycaffe\n```\n\n#### 使用Python Layer\n在网络的prototxt文件中添加一个Python定义的loss层如下：\n```\nlayer{\ntype: ’Python'\nname: 'loss'\ntop: 'loss'\nbottom： ‘ipx’\nbottom: 'ipy'\npython_param{\n#module的名字，通常是定义Layer的.py文件的文件名，需要在$PYTHONPATH下\nmodule: 'pyloss'\n#layer的名字---module中的类名\nlayer: 'EuclideanLossLayer'\n}\nloss_weight: 1\n}\n```\n\n#### 定义Python Layer\n根据上面的要求，我们在$PYTHONPAT在创建pyloss.py，并在其中定义EuclideanLossLayer。\n```Python\nimport caffe\nimport numpy as np\nclass EuclideadLossLayer(caffe.Layer):#EuclideadLossLayer没有权值，反向传播过程中不需要进行权值的更新。如果需要定义需要更新自身权值的层，最好还是使用C++\n       def setup(self,bottom,top):\n           #在网络运行之前根据相关参数参数进行layer的初始化\n           if len(bottom) !=2:\n              raise exception(\"Need two inputs to compute distance\")\n       def reshape(self,bottom,top):\n           #在forward之前调用，根据bottom blob的尺寸调整中间变量和top blob的尺寸\n           if bottom[0].count !=bottom[1].count:\n              raise exception(\"Inputs must have the same dimension.\")\n           self.diff=np.zeros_like(bottom[0].date,dtype=np.float32)\n           top[0].reshape(1)\n       def forward(self,bottom,top):\n           #网络的前向传播\n            self.diff[...]=bottom[0].data-bottom[1].data\n            top[0].data[...]=np.sum(self.diff**2)/bottom[0].num/2.\n       def backward(self,top,propagate_down,bootm):\n            #网络的前向传播\n             for i in range(2):\n                 if not propagate_down[i]:\n                         continue\n                 if i==0:\n                    sign=1\n                 else:\n                    sign=-1\n                  bottom[i].diff[...]=sign*self.diff/bottom[i].num\n\n```\n#### 原理浅析\n阅读caffe源码python_layer.hpp可以知道，类PythonLayer继承自Layer，并且新增私有变量boost::python::object self_来表示我们自己定义的python layer的内存对象。\n\n类PythonLayer类的成员函数LayerSetUP, Reshape, Forward_cpu和Backward_cpu分别是对我们自己定义的python layer中成员函数setup, reshape, forward和backward的封装调用。\n```C++\nclass PythonLayer : public Layer<Dtype> {\n public:\n  PythonLayer(PyObject* self, const LayerParameter& param)\n      : Layer<Dtype>(param), self_(bp::handle<>(bp::borrowed(self))) { }\n\n  virtual void LayerSetUp(const vector<Blob<Dtype>*>& bottom,\n      const vector<Blob<Dtype>*>& top) {\n    // Disallow PythonLayer in MultiGPU training stage, due to GIL issues\n    // Details: https://github.com/BVLC/caffe/issues/2936\n    if (this->phase_ == TRAIN && Caffe::solver_count() > 1\n        && !ShareInParallel()) {\n      LOG(FATAL) << \"PythonLayer is not implemented in Multi-GPU training\";\n    }\n    self_.attr(\"param_str\") = bp::str(\n        this->layer_param_.python_param().param_str());\n    self_.attr(\"setup\")(bottom, top);\n  }\n  virtual void Reshape(const vector<Blob<Dtype>*>& bottom,\n      const vector<Blob<Dtype>*>& top) {\n    self_.attr(\"reshape\")(bottom, top);\n  }\n\n  virtual inline bool ShareInParallel() const {\n    return this->layer_param_.python_param().share_in_parallel();\n  }\n\n  virtual inline const char* type() const { return \"Python\"; }\n\n protected:\n  virtual void Forward_cpu(const vector<Blob<Dtype>*>& bottom,\n      const vector<Blob<Dtype>*>& top) {\n    self_.attr(\"forward\")(bottom, top);\n  }\n  virtual void Backward_cpu(const vector<Blob<Dtype>*>& top,\n      const vector<bool>& propagate_down, const vector<Blob<Dtype>*>& bottom) {\n    self_.attr(\"backward\")(top, propagate_down, bottom);\n  }\n\n private:\n  bp::object self_;\n};\n\n```\n\n[进一步了解使用C++创建新layer](http://chrischoy.github.io/research/making-caffe-layer/)\n**参考资料**\n\n* https://github.com/BVLC/caffe/pull/1703\n* https://gist.github.com//shelhamer/8d9a94cf75e6fb2df221\n","source":"_posts/Caffe-with-Python-Layer.md","raw":"title: 在Caffe中使用Python Layer\ndate: 2016-04-14 11:10:01\ntags: [机器学习,深度学习,Caffe]\n---\n\n#### Caffe通过Boost中的Boost.Python模块来支持使用Python定义Layer：\n\n* 使用C++增加新的Layer**繁琐**、**耗时**而且很容易**出错**\n* **开发速度**与**执行速度**之间的**trade-off**\n\n\n#### 编译支持Python Layer的Caffe\n\n如果是首次编译，修改Caffe根目录下的Makefile.cinfig，uncomment\n```\nWITH_PYTHON_LAYER:=1\n```\n 如果已经编译过\n```\nmake clean\nWITH_PYTHON_LAYER=1 make&& make pycaffe\n```\n\n#### 使用Python Layer\n在网络的prototxt文件中添加一个Python定义的loss层如下：\n```\nlayer{\ntype: ’Python'\nname: 'loss'\ntop: 'loss'\nbottom： ‘ipx’\nbottom: 'ipy'\npython_param{\n#module的名字，通常是定义Layer的.py文件的文件名，需要在$PYTHONPATH下\nmodule: 'pyloss'\n#layer的名字---module中的类名\nlayer: 'EuclideanLossLayer'\n}\nloss_weight: 1\n}\n```\n\n#### 定义Python Layer\n根据上面的要求，我们在$PYTHONPAT在创建pyloss.py，并在其中定义EuclideanLossLayer。\n```Python\nimport caffe\nimport numpy as np\nclass EuclideadLossLayer(caffe.Layer):#EuclideadLossLayer没有权值，反向传播过程中不需要进行权值的更新。如果需要定义需要更新自身权值的层，最好还是使用C++\n       def setup(self,bottom,top):\n           #在网络运行之前根据相关参数参数进行layer的初始化\n           if len(bottom) !=2:\n              raise exception(\"Need two inputs to compute distance\")\n       def reshape(self,bottom,top):\n           #在forward之前调用，根据bottom blob的尺寸调整中间变量和top blob的尺寸\n           if bottom[0].count !=bottom[1].count:\n              raise exception(\"Inputs must have the same dimension.\")\n           self.diff=np.zeros_like(bottom[0].date,dtype=np.float32)\n           top[0].reshape(1)\n       def forward(self,bottom,top):\n           #网络的前向传播\n            self.diff[...]=bottom[0].data-bottom[1].data\n            top[0].data[...]=np.sum(self.diff**2)/bottom[0].num/2.\n       def backward(self,top,propagate_down,bootm):\n            #网络的前向传播\n             for i in range(2):\n                 if not propagate_down[i]:\n                         continue\n                 if i==0:\n                    sign=1\n                 else:\n                    sign=-1\n                  bottom[i].diff[...]=sign*self.diff/bottom[i].num\n\n```\n#### 原理浅析\n阅读caffe源码python_layer.hpp可以知道，类PythonLayer继承自Layer，并且新增私有变量boost::python::object self_来表示我们自己定义的python layer的内存对象。\n\n类PythonLayer类的成员函数LayerSetUP, Reshape, Forward_cpu和Backward_cpu分别是对我们自己定义的python layer中成员函数setup, reshape, forward和backward的封装调用。\n```C++\nclass PythonLayer : public Layer<Dtype> {\n public:\n  PythonLayer(PyObject* self, const LayerParameter& param)\n      : Layer<Dtype>(param), self_(bp::handle<>(bp::borrowed(self))) { }\n\n  virtual void LayerSetUp(const vector<Blob<Dtype>*>& bottom,\n      const vector<Blob<Dtype>*>& top) {\n    // Disallow PythonLayer in MultiGPU training stage, due to GIL issues\n    // Details: https://github.com/BVLC/caffe/issues/2936\n    if (this->phase_ == TRAIN && Caffe::solver_count() > 1\n        && !ShareInParallel()) {\n      LOG(FATAL) << \"PythonLayer is not implemented in Multi-GPU training\";\n    }\n    self_.attr(\"param_str\") = bp::str(\n        this->layer_param_.python_param().param_str());\n    self_.attr(\"setup\")(bottom, top);\n  }\n  virtual void Reshape(const vector<Blob<Dtype>*>& bottom,\n      const vector<Blob<Dtype>*>& top) {\n    self_.attr(\"reshape\")(bottom, top);\n  }\n\n  virtual inline bool ShareInParallel() const {\n    return this->layer_param_.python_param().share_in_parallel();\n  }\n\n  virtual inline const char* type() const { return \"Python\"; }\n\n protected:\n  virtual void Forward_cpu(const vector<Blob<Dtype>*>& bottom,\n      const vector<Blob<Dtype>*>& top) {\n    self_.attr(\"forward\")(bottom, top);\n  }\n  virtual void Backward_cpu(const vector<Blob<Dtype>*>& top,\n      const vector<bool>& propagate_down, const vector<Blob<Dtype>*>& bottom) {\n    self_.attr(\"backward\")(top, propagate_down, bottom);\n  }\n\n private:\n  bp::object self_;\n};\n\n```\n\n[进一步了解使用C++创建新layer](http://chrischoy.github.io/research/making-caffe-layer/)\n**参考资料**\n\n* https://github.com/BVLC/caffe/pull/1703\n* https://gist.github.com//shelhamer/8d9a94cf75e6fb2df221\n","slug":"Caffe-with-Python-Layer","published":1,"updated":"2016-11-29T13:47:45.928Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw3lgivo000twsgsa4gjb1ik"},{"title":"C++中的虚","date":"2016-04-16T12:32:56.000Z","_content":"C++中主要有虚函数，纯虚函数和虚继承三种“虚”。之前的[一篇文章](http://withwsf.github.io/2016/03/21/C-%E4%B8%AD%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/)中我们讲过虚函数的实现原理。下面继续讲一讲纯虚函数和虚继承。\n#### 纯虚函数\n而对于纯虚函数与虚函数的区别，可以概括为————虚函数可以让派生类选择单纯继承接口还是同时继承接口与实现，而纯虚函数强制规定派生类只继承接口并自己实现函数。\n\n* 定义了纯虚函数的类称为抽象类，抽象类不能够被实例化\n```C++\nclass abstractClass{\npublic:\nvirtual void pure_virtual()=0; //通用的纯虚函数声明方式\n};\n```\n* 纯虚函数一般只给出声明而不给出定义，如果要给出定义的话，形式如下：\n```C++\nvoid abstractClass::pure_virtual(){\nstd::cout<<\"This is abstractClass::pure_virtual !\"\n}\n```\n* 只有给出纯虚函数实现的派生类才能够被实例化，否则派生类仍然是抽象类\n```C++\nclass child: public abstractClass{\n  virtual void pure_virtual();\n}\nvoid child::pure_virtual(){\n  abstractClass::pure_virtual();//这里只是距离如果纯虚函数给出了实现的话如何使用\n}\n\n```\n\n#### 虚继承\n* 在普通继承中，派生类对象来将从基类对象继承来的非静态成员变量与自身的非静态成员变量放在同一块连续的内存中\n```C++\nclass Parent{//打印出基类对象中非静态成员变量与派生类对象中非静态成员变量在内存中的offset\n  //可以帮助我们进行理解\npublic:\n    int a;\n    int b;\n\n    virtual void foo(){\n        cout << \"parent\" << endl;\n    }\n};\n\nclass Child : public Parent{\npublic:\n    int c;\n    int d;\n\n    virtual void foo(){\n        cout << \"child\" << endl;\n    }\n};\n\nint main(){\n\n    Parent p;\n    Child c;\n\n    p.foo();\n    c.foo();\n\n    cout << \"Parent Offset a = \" << (size_t)&p.a - (size_t)&p << endl;\n    cout << \"Parent Offset b = \" << (size_t)&p.b - (size_t)&p << endl;\n\n    cout << \"Child Offset a = \" << (size_t)&c.a - (size_t)&c << endl;\n    cout << \"Child Offset b = \" << (size_t)&c.b - (size_t)&c << endl;\n    cout << \"Child Offset c = \" << (size_t)&c.c - (size_t)&c << endl;\n    cout << \"Child Offset d = \" << (size_t)&c.d - (size_t)&c << endl;\n\n    system(\"pause\");\n}\n```\n最终输出结果是：\n```\nparent\nchild\nParent Offset a = 8\nParent Offset b = 12\nChild Offset a = 8\nChild Offset b = 12\nChild Offset c = 16\nChild Offset d = 20\n```\n* 在多重继承中，如果继续使用单继承中的内存布局方法，可以会引起多种问题，需要另外进行设计。\n\n考虑如下的继承关系:\n```C++\nclass B{\npublic:\nvoid foo(){\n  cout<<\"B\"<<endl;\n}\n\n};\n\nclass C:public B{\n};\n\nclass D:public B{\n};\n\nclass E:public C,public D{\n\n};\n\nint main(){\n  E e;\n  e.foo();//将会报错，比如在qt creator中编译器将抛出\n          //error: request for member 'foo' is ambiguous e.foo()\n}\n```\n上面的代码中，派生类E有两个基类C和D，而C和D都有一个共同的基类B。这样e中就有两个B的对象，那么自然\n在调用e.foo()的时候会产生歧义。另外，由于重复保存了B的对象，还会造成内存浪费。\n\n为了防止上面的现象，引入了虚继承————继承基类时使用virtual关键字：\n```C++\nclass B{\npublic:\nvoid foo(){\n  cout<<\"B\"<<endl;\n}\n\n};\n\nclass C:virtual public B{\n};\n\nclass D:virtual public B{\n};\n\nclass E:public C,public D{\n\n};\n```\n“虚”可以认为意味着“在运行时决定”，使用虚继承的派生类在运行时才决定绑定哪个基类。C++并没有具体规定虚继承的\n对象的内存布局，而是由编译器决定如何实现。一般情况下，会在虚继承的派生类对象中增添一个虚基类指针，指向基类对象。比如上面代码中E继承C和D时，会继承C和D的虚基类指针，而C和D的虚基类指针会指向同一个基类B。这样，就实现了E对象中只有一个B对象。\n\n\n#### 参考资料：\n[wikipedia-虚函数](https://wikipedia.kfd.me/zh-cn/%E8%99%9A%E5%87%BD%E6%95%B0_(%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80)\n[memory layout of inherited class](http://stackoverflow.com/questions/8672218/memory-layout-of-inherited-class)\n","source":"_posts/C-中的虚继承.md","raw":"title: C++中的虚\ntags: C++\ndate: 2016-04-16 20:32:56\n---\nC++中主要有虚函数，纯虚函数和虚继承三种“虚”。之前的[一篇文章](http://withwsf.github.io/2016/03/21/C-%E4%B8%AD%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/)中我们讲过虚函数的实现原理。下面继续讲一讲纯虚函数和虚继承。\n#### 纯虚函数\n而对于纯虚函数与虚函数的区别，可以概括为————虚函数可以让派生类选择单纯继承接口还是同时继承接口与实现，而纯虚函数强制规定派生类只继承接口并自己实现函数。\n\n* 定义了纯虚函数的类称为抽象类，抽象类不能够被实例化\n```C++\nclass abstractClass{\npublic:\nvirtual void pure_virtual()=0; //通用的纯虚函数声明方式\n};\n```\n* 纯虚函数一般只给出声明而不给出定义，如果要给出定义的话，形式如下：\n```C++\nvoid abstractClass::pure_virtual(){\nstd::cout<<\"This is abstractClass::pure_virtual !\"\n}\n```\n* 只有给出纯虚函数实现的派生类才能够被实例化，否则派生类仍然是抽象类\n```C++\nclass child: public abstractClass{\n  virtual void pure_virtual();\n}\nvoid child::pure_virtual(){\n  abstractClass::pure_virtual();//这里只是距离如果纯虚函数给出了实现的话如何使用\n}\n\n```\n\n#### 虚继承\n* 在普通继承中，派生类对象来将从基类对象继承来的非静态成员变量与自身的非静态成员变量放在同一块连续的内存中\n```C++\nclass Parent{//打印出基类对象中非静态成员变量与派生类对象中非静态成员变量在内存中的offset\n  //可以帮助我们进行理解\npublic:\n    int a;\n    int b;\n\n    virtual void foo(){\n        cout << \"parent\" << endl;\n    }\n};\n\nclass Child : public Parent{\npublic:\n    int c;\n    int d;\n\n    virtual void foo(){\n        cout << \"child\" << endl;\n    }\n};\n\nint main(){\n\n    Parent p;\n    Child c;\n\n    p.foo();\n    c.foo();\n\n    cout << \"Parent Offset a = \" << (size_t)&p.a - (size_t)&p << endl;\n    cout << \"Parent Offset b = \" << (size_t)&p.b - (size_t)&p << endl;\n\n    cout << \"Child Offset a = \" << (size_t)&c.a - (size_t)&c << endl;\n    cout << \"Child Offset b = \" << (size_t)&c.b - (size_t)&c << endl;\n    cout << \"Child Offset c = \" << (size_t)&c.c - (size_t)&c << endl;\n    cout << \"Child Offset d = \" << (size_t)&c.d - (size_t)&c << endl;\n\n    system(\"pause\");\n}\n```\n最终输出结果是：\n```\nparent\nchild\nParent Offset a = 8\nParent Offset b = 12\nChild Offset a = 8\nChild Offset b = 12\nChild Offset c = 16\nChild Offset d = 20\n```\n* 在多重继承中，如果继续使用单继承中的内存布局方法，可以会引起多种问题，需要另外进行设计。\n\n考虑如下的继承关系:\n```C++\nclass B{\npublic:\nvoid foo(){\n  cout<<\"B\"<<endl;\n}\n\n};\n\nclass C:public B{\n};\n\nclass D:public B{\n};\n\nclass E:public C,public D{\n\n};\n\nint main(){\n  E e;\n  e.foo();//将会报错，比如在qt creator中编译器将抛出\n          //error: request for member 'foo' is ambiguous e.foo()\n}\n```\n上面的代码中，派生类E有两个基类C和D，而C和D都有一个共同的基类B。这样e中就有两个B的对象，那么自然\n在调用e.foo()的时候会产生歧义。另外，由于重复保存了B的对象，还会造成内存浪费。\n\n为了防止上面的现象，引入了虚继承————继承基类时使用virtual关键字：\n```C++\nclass B{\npublic:\nvoid foo(){\n  cout<<\"B\"<<endl;\n}\n\n};\n\nclass C:virtual public B{\n};\n\nclass D:virtual public B{\n};\n\nclass E:public C,public D{\n\n};\n```\n“虚”可以认为意味着“在运行时决定”，使用虚继承的派生类在运行时才决定绑定哪个基类。C++并没有具体规定虚继承的\n对象的内存布局，而是由编译器决定如何实现。一般情况下，会在虚继承的派生类对象中增添一个虚基类指针，指向基类对象。比如上面代码中E继承C和D时，会继承C和D的虚基类指针，而C和D的虚基类指针会指向同一个基类B。这样，就实现了E对象中只有一个B对象。\n\n\n#### 参考资料：\n[wikipedia-虚函数](https://wikipedia.kfd.me/zh-cn/%E8%99%9A%E5%87%BD%E6%95%B0_(%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80)\n[memory layout of inherited class](http://stackoverflow.com/questions/8672218/memory-layout-of-inherited-class)\n","slug":"C-中的虚继承","published":1,"updated":"2016-11-29T13:47:45.924Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciw3lgivr000xwsgsi6msbg8k"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"ciw3lgiuj0000wsgsiiryb2aw","tag_id":"ciw3lgiuo0001wsgs92wkr1xi","_id":"ciw3lgiuq0002wsgs97ba82zu"},{"post_id":"ciw3lgiuz0003wsgsegpw51te","tag_id":"ciw3lgiv00004wsgsiynz1i4r","_id":"ciw3lgiv10006wsgsshkt04vl"},{"post_id":"ciw3lgiuz0003wsgsegpw51te","tag_id":"ciw3lgiv10005wsgs4xyts2zf","_id":"ciw3lgiv10007wsgsw9j87ncm"},{"post_id":"ciw3lgiv20008wsgsopaqqxvo","tag_id":"ciw3lgiv30009wsgsz57qum0g","_id":"ciw3lgiv3000bwsgs0dnkyvfc"},{"post_id":"ciw3lgiv20008wsgsopaqqxvo","tag_id":"ciw3lgiv3000awsgsdppli58q","_id":"ciw3lgiv3000cwsgsgqjnrw9p"},{"post_id":"ciw3lgiv4000dwsgscbat7nnu","tag_id":"ciw3lgiv30009wsgsz57qum0g","_id":"ciw3lgiv6000fwsgsid2cn64e"},{"post_id":"ciw3lgiv4000dwsgscbat7nnu","tag_id":"ciw3lgiv6000ewsgsxohz8ry6","_id":"ciw3lgiv6000gwsgs98oc6eie"},{"post_id":"ciw3lgiv7000hwsgstlqiljt3","tag_id":"ciw3lgiv30009wsgsz57qum0g","_id":"ciw3lgiv9000iwsgs0x6ot4tu"},{"post_id":"ciw3lgiv7000hwsgstlqiljt3","tag_id":"ciw3lgiv3000awsgsdppli58q","_id":"ciw3lgiv9000jwsgsbz07di6r"},{"post_id":"ciw3lgiva000kwsgstfjf9lci","tag_id":"ciw3lgivi000lwsgskp9b3dcg","_id":"ciw3lgivi000mwsgs9pmt2qkq"},{"post_id":"ciw3lgivj000nwsgs92uz4yd8","tag_id":"ciw3lgivl000owsgsc90xed5t","_id":"ciw3lgivl000pwsgsng1gc1bw"},{"post_id":"ciw3lgivm000qwsgsiq87w8wv","tag_id":"ciw3lgiuo0001wsgs92wkr1xi","_id":"ciw3lgivn000rwsgsjtvinoeg"},{"post_id":"ciw3lgivm000qwsgsiq87w8wv","tag_id":"ciw3lgiv6000ewsgsxohz8ry6","_id":"ciw3lgivn000swsgsr089pgk8"},{"post_id":"ciw3lgivo000twsgsa4gjb1ik","tag_id":"ciw3lgiv30009wsgsz57qum0g","_id":"ciw3lgivp000uwsgs6lprz7w0"},{"post_id":"ciw3lgivo000twsgsa4gjb1ik","tag_id":"ciw3lgivi000lwsgskp9b3dcg","_id":"ciw3lgivp000vwsgsu2vf2hr2"},{"post_id":"ciw3lgivo000twsgsa4gjb1ik","tag_id":"ciw3lgiv6000ewsgsxohz8ry6","_id":"ciw3lgivp000wwsgspf5dk6l9"},{"post_id":"ciw3lgivr000xwsgsi6msbg8k","tag_id":"ciw3lgiuo0001wsgs92wkr1xi","_id":"ciw3lgivs000ywsgs7fi3kx8b"}],"Tag":[{"name":"C++","_id":"ciw3lgiuo0001wsgs92wkr1xi"},{"name":"数据挖掘","_id":"ciw3lgiv00004wsgsiynz1i4r"},{"name":"阅读经典","_id":"ciw3lgiv10005wsgs4xyts2zf"},{"name":"机器学习","_id":"ciw3lgiv30009wsgsz57qum0g"},{"name":"Torch","_id":"ciw3lgiv3000awsgsdppli58q"},{"name":"Caffe","_id":"ciw3lgiv6000ewsgsxohz8ry6"},{"name":"深度学习","_id":"ciw3lgivi000lwsgskp9b3dcg"},{"name":"Python","_id":"ciw3lgivl000owsgsc90xed5t"}]}}